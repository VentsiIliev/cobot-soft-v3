<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/GlueDispensingApplication.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/GlueDispensingApplication.py" />
              <option name="originalContent" value="from typing import Dict, Any&#10;&#10;from applications.glue_dispensing_application.services.robot_service.glue_robot_service import GlueRobotService&#10;from applications.glue_dispensing_application.services.workpiece.glue_workpiece_service import GlueWorkpieceService&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application.interfaces.robot_application_interface import RobotApplicationInterface, OperationMode&#10;&#10;import logging&#10;&#10;from backend.system.settings.SettingsService import SettingsService&#10;from core.operations_handlers.camera_calibration_handler import \&#10;    calibrate_camera&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.services.vision.VisionService import _VisionService&#10;# Import base classes&#10;from core.base_robot_application import BaseRobotApplication, ApplicationState, ApplicationMetadata&#10;from applications.glue_dispensing_application.GlueDispensingApplicationStateManager import \&#10;    GlueDispensingApplicationStateManager&#10;from applications.glue_dispensing_application.GlueDispensingMessagePublisher import \&#10;    GlueDispensingMessagePublisher&#10;from applications.glue_dispensing_application.GlueDispensingSubscriptionManager import \&#10;    GlueDispensingSubscriptionManager&#10;from applications.glue_dispensing_application.glue_process.glue_dispensing_operation import \&#10;    GlueDispensingOperation&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import \&#10;    GlueProcessState&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.handlers import spraying_handler, nesting_handler&#10;from applications.glue_dispensing_application.handlers.clean_nozzle_handler import clean_nozzle&#10;from applications.glue_dispensing_application.handlers.create_workpiece_handler import \&#10;    CreateWorkpieceHandler, CrateWorkpieceResult&#10;from applications.glue_dispensing_application.handlers.handle_start import start&#10;from applications.glue_dispensing_application.handlers.match_workpiece_handler import WorkpieceMatcher&#10;from applications.glue_dispensing_application.handlers.temp_handlers.execute_from_gallery_handler import \&#10;    execute_from_gallery&#10;from applications.glue_dispensing_application.handlers.workpieces_to_spray_paths_handler import \&#10;    WorkpieceToSprayPathsGenerator&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;from applications.glue_dispensing_application.settings.GlueSettingsHandler import GlueSettingsHandler&#10;from modules.glueSprayService.GlueSprayService import GlueSprayService&#10;from modules.shared.tools.GlueCell import GlueCellsManagerSingleton, GlueDataFetcher&#10;from core import state_management&#10;&#10;from core.services.workpiece.BaseWorkpieceService import BaseWorkpieceService&#10;&#10;&quot;&quot;&quot;&#10;ENDPOINTS&#10;- start&#10;- measureHeight&#10;- calibrateRobot&#10;- calibrateCamera&#10;- createWorkpiece&#10;&#10;&quot;&quot;&quot;&#10;&#10;Z_OFFSET_FOR_CALIBRATION_PATTERN = -4 # MM&#10;&#10;class GlueSprayingApplication(BaseRobotApplication, RobotApplicationInterface):&#10;    &quot;&quot;&quot;&#10;    ActionManager is responsible for connecting actions to functions.&#10;    The MainWindow will just emit signals, and ActionManager handles them.&#10;    &quot;&quot;&quot;&#10;&#10;    glueCellsManager = GlueCellsManagerSingleton.get_instance()&#10;&#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 workpiece_service: GlueWorkpieceService,&#10;                 robot_service: GlueRobotService,&#10;                 settings_registry: ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        # manager = state_management.SystemStateManager(state_management.SYSTEM_STATE_PRIORITY)&#10;        # manager.register_service(&quot;robot_service&quot;, state_management.ServiceState.INITIALIZING)&#10;        # manager.register_service(&quot;vision_service&quot;, state_management.ServiceState.INITIALIZING)&#10;&#10;        # Initialize logger first (before base class to avoid issues)&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;        # register glue meters&#10;        glue_fetcher = GlueDataFetcher()&#10;        glue_fetcher.start()&#10;        self.robot_service = robot_service&#10;        # Initialize the base class&#10;        super().__init__(vision_service, settings_manager, self.robot_service,settings_registry)&#10;&#10;        # Register application-specific settings after initialization&#10;        self._register_settings()&#10;&#10;        # Override the base managers with glue dispensing specific extensions&#10;        self.workpiece_service=workpiece_service&#10;        self.message_publisher = GlueDispensingMessagePublisher(self.message_publisher)&#10;        self.state_manager = GlueDispensingApplicationStateManager(self.state_manager)&#10;        self.subscription_manager = GlueDispensingSubscriptionManager(self, self.subscription_manager)&#10;        &#10;        # Update subscriptions with the extended manager&#10;        self.subscription_manager.subscribe_all()&#10;&#10;        # Application-specific initialization&#10;        self.preselected_workpiece = None&#10;        self.workpiece_to_spray_paths_generator = WorkpieceToSprayPathsGenerator(self)&#10;        self.create_workpiece_handler = CreateWorkpieceHandler(self)&#10;        &#10;        # Initialize glue process state machine for operation control&#10;&#10;        self.glue_process_state_machine = GlueProcessStateMachine(GlueProcessState.INITIALIZING)&#10;        self.workpiece_matcher = WorkpieceMatcher()&#10;&#10;        # Initialize glue dispensing operation with proper settings access&#10;        self.glue_dispensing_operation = GlueDispensingOperation(self.robot_service, self)&#10;&#10;        self.NESTING = True&#10;        self.CONTOUR_MATCHING = True&#10;        self.current_operation = None&#10;&#10;    @property&#10;    def metadata(self) -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(&#10;            name=&quot;Glue Spraying Application&quot;,&#10;            version=&quot;1.0.0&quot;,&#10;            dependencies=[&quot;_VisionService&quot;,&#10;                          &quot;SettingsService&quot;,&#10;                          &quot;GlueRobotService&quot;,&#10;                          &quot;ApplicationSettingsRegistry&quot;],&#10;        )&#10;    # ========== BaseRobotApplication Abstract Methods Implementation ==========&#10;    &#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    def start(self, mode: OperationMode = OperationMode.AUTOMATIC, debug=True, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Start the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            result = start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;            # self.state_manager.update_state(ApplicationState.RUNNING)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation started&quot;,&#10;                &quot;mode&quot;: mode.value,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            import traceback&#10;            traceback.print_exc()&#10;            # self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to start operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def start_nesting(self, debug=True):&#10;        self.current_operation = &quot;Nesting&quot;&#10;        return nesting_handler.start_nesting(self, self.get_workpieces())&#10;&#10;    def start_spraying(self,workpieces, debug=True):&#10;        self.current_operation = &quot;Spraying&quot;&#10;        return spraying_handler.start_spraying(self, workpieces, debug)&#10;&#10;    def move_to_nesting_capture_position(self):&#10;        z_offset = self.settingsManager.get_camera_settings().get_capture_pos_offset()&#10;        return self.robot_service.move_to_nesting_capture_position(z_offset)&#10;&#10;    def move_to_spray_capture_position(self):&#10;        z_offset = self.settingsManager.get_camera_settings().get_capture_pos_offset()&#10;        return self.robot_service.move_to_spray_capture_position(z_offset)&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    def clean_nozzle(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Clean the robot nozzle.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return clean_nozzle(self.robot_service)&#10;&#10;    def clean_tool(self, tool_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Clean a specific tool (e.g., nozzle cleaning)&quot;&quot;&quot;&#10;        try:&#10;            if tool_id == &quot;nozzle&quot;:&#10;                result = self.clean_nozzle()&#10;                return {&#10;                    &quot;success&quot;: True,&#10;                    &quot;message&quot;: f&quot;Tool {tool_id} cleaned successfully&quot;,&#10;                    &quot;data&quot;: result&#10;                }&#10;            else:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Tool {tool_id} not supported for cleaning&quot;&#10;                }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to clean tool: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def home_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Move robot to home position&quot;&quot;&quot;&#10;        try:&#10;            # Use robot service to move to home position&#10;            result = self.robot_service.moveToStartPosition()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Robot moved to home position&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to home robot: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def stop(self, emergency: bool = False) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Stop the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.STOPPED)&#10;            result = self.glue_dispensing_operation.stop_operation()&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation stopped&quot;,&#10;                &quot;emergency&quot;: emergency,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to stop operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Pause the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.PAUSED)&#10;            self.glue_dispensing_operation.pause_operation()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation paused&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to pause operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Resume the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.STARTED)&#10;            self.glue_dispensing_operation.resume_operation()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation resumed&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to resume operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def reset(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Reset the robot application to initial state&quot;&quot;&quot;&#10;        try:&#10;            # Stop any ongoing operation&#10;            self.stop()&#10;            &#10;            # Reset to initial state&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            &#10;            # Clear preselected workpiece&#10;            self.preselected_workpiece = None&#10;            &#10;            # Reset modes to default&#10;            self.NESTING = True&#10;            self.CONTOUR_MATCHING = True&#10;            &#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Application reset to initial state&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to reset application: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            } # TODO not used!&#10;&#10;    # ========== Calibration Management ==========&#10;    &#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the robot coordinate system&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.CALIBRATING)&#10;            result = calibrate_robot(self)&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Robot calibration completed&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Robot calibration failed: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the camera system&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.CALIBRATING)&#10;            result = calibrate_camera(self)&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Camera calibration completed&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Camera calibration failed: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    # Legacy methods for backward compatibility&#10;    def calibrateRobot(self):&#10;        return self.calibrate_robot()&#10;&#10;    def calibrateCamera(self):&#10;        return self.calibrate_camera()&#10;&#10;    def create_workpiece(self) -&gt; CrateWorkpieceResult:&#10;        return  self.create_workpiece_handler.create_workpiece()&#10;&#10;    # ========== Workpiece Handling ==========&#10;    &#10;    def load_workpiece(self, workpiece_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Load a workpiece for processing&quot;&quot;&quot;&#10;        try:&#10;            workpiece = self.workpiece_service.get_workpiece_by_id(workpiece_id)&#10;            if workpiece is None:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Workpiece with ID {workpiece_id} not found&quot;&#10;                }&#10;            &#10;            self.preselected_workpiece = workpiece&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} loaded successfully&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;workpiece_name&quot;: workpiece.name if hasattr(workpiece, 'name') else 'Unknown'&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to load workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def process_workpiece(self, workpiece_id: str, **parameters) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Process a workpiece with the robot application&quot;&quot;&quot;&#10;        try:&#10;            # Load the workpiece&#10;            load_result = self.load_workpiece(workpiece_id)&#10;            if not load_result[&quot;success&quot;]:&#10;                return load_result&#10;            &#10;            # Start the dispensing operation&#10;            start_result = self.start(**parameters)&#10;            &#10;            return {&#10;                &quot;success&quot;: start_result[&quot;success&quot;],&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} processing {'started' if start_result['success'] else 'failed'}&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;processing_result&quot;: start_result&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to process workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def get_workpieces(self):&#10;        &quot;&quot;&quot;Legacy method for backward compatibility&quot;&quot;&quot;&#10;        if self.preselected_workpiece is None:&#10;            workpieces = self.workpiece_service.load_all()&#10;            print(f&quot; Loaded workpieces: {len(workpieces)}&quot;)&#10;        else:&#10;            workpieces = [self.preselected_workpiece]&#10;            print(f&quot; Using preselected workpiece: {self.preselected_workpiece.name}&quot;)&#10;        return workpieces&#10;&#10;    def get_dynamic_offsets_config(self):&#10;        &quot;&quot;&quot;&#10;        Return the dynamic offset configuration including step offsets and direction map.&#10;        &quot;&quot;&quot;&#10;        # Step offsets&#10;        x_step_offset = self.robot_service.robot_config.tcp_x_step_offset&#10;        y_step_offset = self.robot_service.robot_config.tcp_y_step_offset&#10;&#10;        # Optionally: distances (if still used)&#10;        x_distance = getattr(self.robot_service.robot_config, 'tcp_x_step_distance', 50.0)&#10;        y_distance = getattr(self.robot_service.robot_config, 'tcp_y_step_distance', 50.0)&#10;&#10;        # Direction map&#10;        direction_map = self.robot_service.robot_config.offset_direction_map&#10;        # print(f&quot;in get_dynamic_offsets_config: direction_map={direction_map}&quot;)&#10;        return x_distance, x_step_offset, y_distance, y_step_offset, direction_map&#10;&#10;    def get_transducer_offsets(self):&#10;        # NOTE:&#10;        # - The offsets defined here are measured in the robot's 0° TCP (Tool Center Point) orientation.&#10;&#10;        x_offset = self.robot_service.robot_config.tcp_x_offset # to the top left corner of the transducer&#10;        y_offset = self.robot_service.robot_config.tcp_y_offset # to the top left corner of the transducer&#10;&#10;        # print(f&quot;Transducer offsets: x_offset={x_offset}, y_offset={y_offset}&quot;)&#10;        return [x_offset, y_offset]&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handleExecuteFromGallery(self, workpiece):&#10;        return execute_from_gallery(self,workpiece,Z_OFFSET_FOR_CALIBRATION_PATTERN)&#10;&#10;    def changeMode(self,message):&#10;        print(f&quot;Changing mode to: {message}&quot;)&#10;        if message == &quot;Spray Only&quot;:&#10;            self.NESTING = False&#10;        elif message == &quot;Pick And Spray&quot;:&#10;            self.NESTING = True&#10;        else:&#10;            raise ValueError(f&quot;Unknown mode: {message}&quot;)&#10;&#10;    def run_demo(self):&#10;&#10;        if self.preselected_workpiece is None:&#10;            print(f&quot;No preselected workpiece set for demo&quot;)&#10;            return False, &quot;No preselected workpiece set for demo&quot;&#10;&#10;        workpiece = self.workpiece_service.get_workpiece_by_id(self.preselected_workpiece)&#10;        if workpiece is None:&#10;            print(f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;)&#10;            return True, f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;&#10;&#10;        print(&quot;Demo workpiece found: &quot;, workpiece)&#10;        return True, &quot;Demo workpiece found&quot;&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handle_set_preselected_workpiece(self, wp_id):&#10;&#10;        selected_workpiece = None&#10;        all_workpieces = self.workpiece_service.load_all()&#10;        for wp in all_workpieces:&#10;            if str(wp.workpieceId) == str(wp_id):&#10;                selected_workpiece = wp&#10;                break&#10;&#10;        if selected_workpiece is not None:&#10;            self.preselected_workpiece = selected_workpiece&#10;            print(f&quot;Preselected workpiece set to ID: {wp_id}&quot;)&#10;            print(f&quot;Workpiece: {selected_workpiece}&quot;)&#10;            print(f&quot;Pickup point: {selected_workpiece.pickupPoint}&quot;)&#10;&#10;            return True, f&quot;Preselected workpiece set to ID: {wp_id}&quot;&#10;        else:&#10;            print(f&quot;Workpiece with ID: {wp_id} not found&quot;)&#10;            return False, f&quot;Workpiece with ID: {wp_id} not found&quot;&#10;&#10;    # ========== Application-Specific Information ==========&#10;&#10;    def _register_settings(self):&#10;        &quot;&quot;&quot;Register glue application settings with the global settings registry&quot;&quot;&quot;&#10;        try:&#10;            # Create glue settings instance&#10;            glue_settings = GlueSettings()&#10;            &#10;            # Create glue settings handler  &#10;            glue_handler = GlueSettingsHandler()&#10;            &#10;            # Register both with the global registry&#10;            self.settings_registry.register_settings_type(glue_settings)&#10;            self.settings_registry.register_handler(glue_handler)&#10;            &#10;            self.logger.info(&quot;Glue application settings registered successfully&quot;)&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to register glue application settings: {e}&quot;)&#10;&#10;    def get_glue_settings(self):&#10;        &quot;&quot;&quot;Get glue settings object for this application&quot;&quot;&quot;&#10;        try:&#10;            handler = self.settings_registry.get_handler(&quot;glue&quot;)&#10;            return handler.get_settings_object()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to get glue settings: {e}&quot;)&#10;            # Fallback to default settings&#10;            return GlueSettings()&#10;" />
              <option name="updatedContent" value="from typing import Dict, Any&#10;&#10;from applications.glue_dispensing_application.services.robot_service.glue_robot_service import GlueRobotService&#10;from applications.glue_dispensing_application.services.workpiece.glue_workpiece_service import GlueWorkpieceService&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application.interfaces.robot_application_interface import RobotApplicationInterface, OperationMode&#10;&#10;import logging&#10;&#10;from backend.system.settings.SettingsService import SettingsService&#10;from core.operations_handlers.camera_calibration_handler import \&#10;    calibrate_camera&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.services.vision.VisionService import _VisionService&#10;# Import base classes&#10;from core.base_robot_application import BaseRobotApplication, ApplicationState, ApplicationMetadata&#10;from applications.glue_dispensing_application.GlueDispensingApplicationStateManager import \&#10;    GlueDispensingApplicationStateManager&#10;from applications.glue_dispensing_application.GlueDispensingMessagePublisher import \&#10;    GlueDispensingMessagePublisher&#10;from applications.glue_dispensing_application.GlueDispensingSubscriptionManager import \&#10;    GlueDispensingSubscriptionManager&#10;from applications.glue_dispensing_application.glue_process.glue_dispensing_operation import \&#10;    GlueDispensingOperation&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import \&#10;    GlueProcessState&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.handlers import spraying_handler, nesting_handler&#10;from applications.glue_dispensing_application.handlers.clean_nozzle_handler import clean_nozzle&#10;from applications.glue_dispensing_application.handlers.create_workpiece_handler import \&#10;    CreateWorkpieceHandler, CrateWorkpieceResult&#10;from applications.glue_dispensing_application.handlers.handle_start import start&#10;from applications.glue_dispensing_application.handlers.match_workpiece_handler import WorkpieceMatcher&#10;from applications.glue_dispensing_application.handlers.temp_handlers.execute_from_gallery_handler import \&#10;    execute_from_gallery&#10;from applications.glue_dispensing_application.handlers.workpieces_to_spray_paths_handler import \&#10;    WorkpieceToSprayPathsGenerator&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;from applications.glue_dispensing_application.settings.GlueSettingsHandler import GlueSettingsHandler&#10;from modules.glueSprayService.GlueSprayService import GlueSprayService&#10;from modules.shared.tools.GlueCell import GlueCellsManagerSingleton, GlueDataFetcher&#10;from core import state_management&#10;&#10;from core.services.workpiece.BaseWorkpieceService import BaseWorkpieceService&#10;&#10;&quot;&quot;&quot;&#10;ENDPOINTS&#10;- start&#10;- measureHeight&#10;- calibrateRobot&#10;- calibrateCamera&#10;- createWorkpiece&#10;&#10;&quot;&quot;&quot;&#10;&#10;Z_OFFSET_FOR_CALIBRATION_PATTERN = -4 # MM&#10;&#10;class GlueSprayingApplication(BaseRobotApplication, RobotApplicationInterface):&#10;    &quot;&quot;&quot;&#10;    ActionManager is responsible for connecting actions to functions.&#10;    The MainWindow will just emit signals, and ActionManager handles them.&#10;    &quot;&quot;&quot;&#10;&#10;    glueCellsManager = GlueCellsManagerSingleton.get_instance()&#10;&#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 workpiece_service: GlueWorkpieceService,&#10;                 robot_service: GlueRobotService,&#10;                 settings_registry: ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        # manager = state_management.SystemStateManager(state_management.SYSTEM_STATE_PRIORITY)&#10;        # manager.register_service(&quot;robot_service&quot;, state_management.ServiceState.INITIALIZING)&#10;        # manager.register_service(&quot;vision_service&quot;, state_management.ServiceState.INITIALIZING)&#10;&#10;        # Initialize logger first (before base class to avoid issues)&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;        # register glue meters&#10;        glue_fetcher = GlueDataFetcher()&#10;        glue_fetcher.start()&#10;        self.robot_service = robot_service&#10;        # Initialize the base class&#10;        super().__init__(vision_service, settings_manager, self.robot_service,settings_registry)&#10;&#10;        # Register application-specific settings after initialization&#10;        self._register_settings()&#10;&#10;        # Override the base managers with glue dispensing specific extensions&#10;        self.workpiece_service=workpiece_service&#10;        self.message_publisher = GlueDispensingMessagePublisher(self.message_publisher)&#10;        self.state_manager = GlueDispensingApplicationStateManager(self.state_manager)&#10;        self.subscription_manager = GlueDispensingSubscriptionManager(self, self.subscription_manager)&#10;        &#10;        # Update subscriptions with the extended manager&#10;        self.subscription_manager.subscribe_all()&#10;&#10;        # Application-specific initialization&#10;        self.preselected_workpiece = None&#10;        self.workpiece_to_spray_paths_generator = WorkpieceToSprayPathsGenerator(self)&#10;        self.create_workpiece_handler = CreateWorkpieceHandler(self)&#10;        &#10;        # Initialize glue process state machine for operation control&#10;&#10;        self.glue_process_state_machine = GlueProcessStateMachine(GlueProcessState.INITIALIZING)&#10;        self.workpiece_matcher = WorkpieceMatcher()&#10;&#10;        # Initialize glue dispensing operation with proper settings access&#10;        self.glue_dispensing_operation = GlueDispensingOperation(self.robot_service, self)&#10;&#10;        self.NESTING = True&#10;        self.CONTOUR_MATCHING = True&#10;        self.current_operation = None&#10;&#10;    @property&#10;    def metadata(self) -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(&#10;            name=&quot;Glue Spraying Application&quot;,&#10;            version=&quot;1.0.0&quot;,&#10;            dependencies=[&quot;_VisionService&quot;,&#10;                          &quot;SettingsService&quot;,&#10;                          &quot;GlueRobotService&quot;,&#10;                          &quot;ApplicationSettingsRegistry&quot;],&#10;        )&#10;    # ========== BaseRobotApplication Abstract Methods Implementation ==========&#10;    &#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    def start(self, mode: OperationMode = OperationMode.AUTOMATIC, debug=True, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Start the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            result = start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;            # self.state_manager.update_state(ApplicationState.RUNNING)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation started&quot;,&#10;                &quot;mode&quot;: mode.value,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            import traceback&#10;            traceback.print_exc()&#10;            # self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to start operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def start_nesting(self, debug=True):&#10;        self.current_operation = &quot;Nesting&quot;&#10;        return nesting_handler.start_nesting(self, self.get_workpieces())&#10;&#10;    def start_spraying(self,workpieces, debug=True):&#10;        self.current_operation = &quot;Spraying&quot;&#10;        return spraying_handler.start_spraying(self, workpieces, debug)&#10;&#10;    def move_to_nesting_capture_position(self):&#10;        z_offset = self.settingsManager.get_camera_settings().get_capture_pos_offset()&#10;        return self.robot_service.move_to_nesting_capture_position(z_offset)&#10;&#10;    def move_to_spray_capture_position(self):&#10;        z_offset = self.settingsManager.get_camera_settings().get_capture_pos_offset()&#10;        return self.robot_service.move_to_spray_capture_position(z_offset)&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    def clean_nozzle(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Clean the robot nozzle.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return clean_nozzle(self.robot_service)&#10;&#10;    def clean_tool(self, tool_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Clean a specific tool (e.g., nozzle cleaning)&quot;&quot;&quot;&#10;        try:&#10;            if tool_id == &quot;nozzle&quot;:&#10;                result = self.clean_nozzle()&#10;                return {&#10;                    &quot;success&quot;: True,&#10;                    &quot;message&quot;: f&quot;Tool {tool_id} cleaned successfully&quot;,&#10;                    &quot;data&quot;: result&#10;                }&#10;            else:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Tool {tool_id} not supported for cleaning&quot;&#10;                }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to clean tool: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def home_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Move robot to home position&quot;&quot;&quot;&#10;        try:&#10;            # Use robot service to move to home position&#10;            result = self.robot_service.moveToStartPosition()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Robot moved to home position&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to home robot: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def stop(self, emergency: bool = False) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Stop the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.STOPPED)&#10;            result = self.glue_dispensing_operation.stop_operation()&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation stopped&quot;,&#10;                &quot;emergency&quot;: emergency,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to stop operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Pause the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.PAUSED)&#10;            self.glue_dispensing_operation.pause_operation()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation paused&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to pause operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Resume the robot application operation&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.STARTED)&#10;            self.glue_dispensing_operation.resume_operation()&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Glue dispensing operation resumed&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to resume operation: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def reset(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Reset the robot application to initial state&quot;&quot;&quot;&#10;        try:&#10;            # Stop any ongoing operation&#10;            self.stop()&#10;            &#10;            # Reset to initial state&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            &#10;            # Clear preselected workpiece&#10;            self.preselected_workpiece = None&#10;            &#10;            # Reset modes to default&#10;            self.NESTING = True&#10;            self.CONTOUR_MATCHING = True&#10;            &#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Application reset to initial state&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to reset application: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            } # TODO not used!&#10;&#10;    # ========== Calibration Management ==========&#10;    &#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the robot coordinate system&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.CALIBRATING)&#10;            result = calibrate_robot(self)&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Robot calibration completed&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Robot calibration failed: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the camera system&quot;&quot;&quot;&#10;        try:&#10;            self.state_manager.update_state(ApplicationState.CALIBRATING)&#10;            result = calibrate_camera(self)&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Camera calibration completed&quot;,&#10;                &quot;data&quot;: result&#10;            }&#10;        except Exception as e:&#10;            self.state_manager.update_state(ApplicationState.ERROR)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Camera calibration failed: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    # Legacy methods for backward compatibility&#10;    def calibrateRobot(self):&#10;        return self.calibrate_robot()&#10;&#10;    def calibrateCamera(self):&#10;        return self.calibrate_camera()&#10;&#10;    def create_workpiece(self) -&gt; CrateWorkpieceResult:&#10;        return  self.create_workpiece_handler.create_workpiece()&#10;&#10;    # ========== Workpiece Handling ==========&#10;    &#10;    def load_workpiece(self, workpiece_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Load a workpiece for processing&quot;&quot;&quot;&#10;        try:&#10;            workpiece = self.workpiece_service.get_workpiece_by_id(workpiece_id)&#10;            if workpiece is None:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Workpiece with ID {workpiece_id} not found&quot;&#10;                }&#10;            &#10;            self.preselected_workpiece = workpiece&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} loaded successfully&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;workpiece_name&quot;: workpiece.name if hasattr(workpiece, 'name') else 'Unknown'&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to load workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def process_workpiece(self, workpiece_id: str, **parameters) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Process a workpiece with the robot application&quot;&quot;&quot;&#10;        try:&#10;            # Load the workpiece&#10;            load_result = self.load_workpiece(workpiece_id)&#10;            if not load_result[&quot;success&quot;]:&#10;                return load_result&#10;            &#10;            # Start the dispensing operation&#10;            start_result = self.start(**parameters)&#10;            &#10;            return {&#10;                &quot;success&quot;: start_result[&quot;success&quot;],&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} processing {'started' if start_result['success'] else 'failed'}&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;processing_result&quot;: start_result&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to process workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def get_workpieces(self):&#10;        &quot;&quot;&quot;Legacy method for backward compatibility&quot;&quot;&quot;&#10;        if self.preselected_workpiece is None:&#10;            workpieces = self.workpiece_service.load_all()&#10;            print(f&quot; Loaded workpieces: {len(workpieces)}&quot;)&#10;        else:&#10;            workpieces = [self.preselected_workpiece]&#10;            print(f&quot; Using preselected workpiece: {self.preselected_workpiece.name}&quot;)&#10;        return workpieces&#10;&#10;    def get_dynamic_offsets_config(self):&#10;        &quot;&quot;&quot;&#10;        Return the dynamic offset configuration including step offsets and direction map.&#10;        &quot;&quot;&quot;&#10;        # Step offsets&#10;        x_step_offset = self.robot_service.robot_config.tcp_x_step_offset&#10;        y_step_offset = self.robot_service.robot_config.tcp_y_step_offset&#10;&#10;        # Optionally: distances (if still used)&#10;        x_distance = getattr(self.robot_service.robot_config, 'tcp_x_step_distance', 50.0)&#10;        y_distance = getattr(self.robot_service.robot_config, 'tcp_y_step_distance', 50.0)&#10;&#10;        # Direction map&#10;        direction_map = self.robot_service.robot_config.offset_direction_map&#10;        # print(f&quot;in get_dynamic_offsets_config: direction_map={direction_map}&quot;)&#10;        return x_distance, x_step_offset, y_distance, y_step_offset, direction_map&#10;&#10;    def get_transducer_offsets(self):&#10;        # NOTE:&#10;        # - The offsets defined here are measured in the robot's 0° TCP (Tool Center Point) orientation.&#10;&#10;        x_offset = self.robot_service.robot_config.tcp_x_offset # to the top left corner of the transducer&#10;        y_offset = self.robot_service.robot_config.tcp_y_offset # to the top left corner of the transducer&#10;&#10;        # print(f&quot;Transducer offsets: x_offset={x_offset}, y_offset={y_offset}&quot;)&#10;        return [x_offset, y_offset]&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handleExecuteFromGallery(self, workpiece):&#10;        return execute_from_gallery(self,workpiece,Z_OFFSET_FOR_CALIBRATION_PATTERN)&#10;&#10;    def changeMode(self,message):&#10;        print(f&quot;Changing mode to: {message}&quot;)&#10;        if message == &quot;Spray Only&quot;:&#10;            self.NESTING = False&#10;        elif message == &quot;Pick And Spray&quot;:&#10;            self.NESTING = True&#10;        else:&#10;            raise ValueError(f&quot;Unknown mode: {message}&quot;)&#10;&#10;    def run_demo(self):&#10;&#10;        if self.preselected_workpiece is None:&#10;            print(f&quot;No preselected workpiece set for demo&quot;)&#10;            return False, &quot;No preselected workpiece set for demo&quot;&#10;&#10;        workpiece = self.workpiece_service.get_workpiece_by_id(self.preselected_workpiece)&#10;        if workpiece is None:&#10;            print(f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;)&#10;            return True, f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;&#10;&#10;        print(&quot;Demo workpiece found: &quot;, workpiece)&#10;        return True, &quot;Demo workpiece found&quot;&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handle_set_preselected_workpiece(self, wp_id):&#10;&#10;        selected_workpiece = None&#10;        all_workpieces = self.workpiece_service.load_all()&#10;        for wp in all_workpieces:&#10;            if str(wp.workpieceId) == str(wp_id):&#10;                selected_workpiece = wp&#10;                break&#10;&#10;        if selected_workpiece is not None:&#10;            self.preselected_workpiece = selected_workpiece&#10;            print(f&quot;Preselected workpiece set to ID: {wp_id}&quot;)&#10;            print(f&quot;Workpiece: {selected_workpiece}&quot;)&#10;            print(f&quot;Pickup point: {selected_workpiece.pickupPoint}&quot;)&#10;&#10;            return True, f&quot;Preselected workpiece set to ID: {wp_id}&quot;&#10;        else:&#10;            print(f&quot;Workpiece with ID: {wp_id} not found&quot;)&#10;            return False, f&quot;Workpiece with ID: {wp_id} not found&quot;&#10;&#10;    # ========== Application-Specific Information ==========&#10;&#10;    def _register_settings(self):&#10;        &quot;&quot;&quot;Register glue application settings with the global settings registry&quot;&quot;&quot;&#10;        try:&#10;            # Create glue settings instance&#10;            glue_settings = GlueSettings()&#10;            &#10;            # Create glue settings handler  &#10;            glue_handler = GlueSettingsHandler()&#10;            &#10;            # Register both with the global registry&#10;            self.settings_registry.register_settings_type(glue_settings)&#10;            self.settings_registry.register_handler(glue_handler)&#10;            &#10;            self.logger.info(&quot;Glue application settings registered successfully&quot;)&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to register glue application settings: {e}&quot;)&#10;&#10;    def get_glue_settings(self):&#10;        &quot;&quot;&quot;Get glue settings object for this application&quot;&quot;&quot;&#10;        try:&#10;            handler = self.settings_registry.get_handler(&quot;glue&quot;)&#10;            return handler.get_settings_object()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to get glue settings: {e}&quot;)&#10;            # Fallback to default settings&#10;            return GlueSettings()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application_state_management.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application_state_management.py" />
              <option name="originalContent" value="from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.application.interfaces.ISubscriptionModule import ISubscriptionModule&#10;&#10;&#10;class SubscriptionManger:&#10;    def __init__(self, owner, broker, subscriptions):&#10;        self.owner = owner&#10;        self.broker = broker&#10;        # Convert list of tuples to dictionary for easier lookup&#10;        if isinstance(subscriptions, list):&#10;            self.subscriptions = {}&#10;            self._initial_subscriptions = subscriptions&#10;        else:&#10;            self.subscriptions = subscriptions&#10;            self._initial_subscriptions = []&#10;        self.modules = []&#10;&#10;    def subscribe_all(self):&#10;        &quot;&quot;&quot;Subscribe all loaded modules.&quot;&quot;&quot;&#10;        # First subscribe to initial subscriptions from constructor&#10;        for subscription in self._initial_subscriptions:&#10;            topic = subscription[0]&#10;            callback = subscription[1]&#10;            print(f&quot;Subscribing to topic: {topic} with callback: {callback}&quot;)&#10;            self._add_subscription(topic, callback)&#10;&#10;    def load_modules(self, modules: list[ISubscriptionModule]):&#10;        for module in modules:&#10;            module.register(self)&#10;            self.modules.append(module)&#10;&#10;    def _add_subscription(self, topic: str, callback):&#10;        self.broker.subscribe(topic, callback)&#10;        self.subscriptions[topic] = callback&#10;&#10;    def _remove_subscription(self, topic):&#10;        if topic in self.subscriptions:&#10;            self.broker.unsubscribe(topic, self.subscriptions[topic])&#10;            del self.subscriptions[topic]&#10;&#10;&#10;from enum import auto, Enum&#10;&#10;from communication_layer.api.v1.topics import VisionTopics, RobotTopics&#10;&#10;&#10;class ApplicationState(Enum):&#10;    &quot;&quot;&quot;Base application states that all robot applications should support&quot;&quot;&quot;&#10;    INITIALIZING = &quot;initializing&quot;&#10;    IDLE = &quot;idle&quot;&#10;    PAUSED = &quot;paused&quot;&#10;    STOPPED = &quot;stopped&quot;&#10;    STARTED = &quot;started&quot;&#10;    ERROR = &quot;error&quot;&#10;    CALIBRATING = &quot;calibrating&quot;&#10;&#10;&#10;class ProcessState(Enum):&#10;    INITIALIZING = auto()&#10;    IDLE = auto()&#10;    STARTING = auto()&#10;    STOPPED = auto()&#10;    PAUSED = auto()&#10;    COMPLETED = auto()&#10;    ERROR = auto()&#10;&#10;&#10;class ApplicationMessagePublisher:&#10;    &quot;&quot;&quot;Extended message publisher for glue dispensing specific messages&quot;&quot;&quot;&#10;&#10;    def __init__(self, broker):&#10;        self.broker=broker&#10;        self.brightness_region_topic = VisionTopics.BRIGHTNESS_REGION&#10;        self.robot_trajectory_image_topic = RobotTopics.TRAJECTORY_UPDATE_IMAGE&#10;        self.trajectory_start_topic = RobotTopics.TRAJECTORY_START&#10;&#10;&#10;    def publish_state(self, state):&#10;        self.broker.publish_state(state)&#10;&#10;    def publish_brightness_region(self, region):&#10;        self.broker.publish(self.brightness_region_topic, {&quot;region&quot;: region})&#10;&#10;    def publish_trajectory_image(self, image):&#10;        self.broker.publish(self.robot_trajectory_image_topic, {&quot;image&quot;: image})&#10;&#10;    def publish_trajectory_start(self):&#10;        self.broker.publish(self.trajectory_start_topic, &quot;&quot;)&#10;&#10;class ApplicationStateManager:&#10;    &quot;&quot;&quot;Extended state manager for glue dispensing specific state handling&quot;&quot;&quot;&#10;&#10;    def __init__(self, message_publisher: ApplicationMessagePublisher):&#10;        self.message_publisher = message_publisher&#10;        self.current_state = ApplicationState.INITIALIZING&#10;        self._services_ready = False  # Flag to indicate when both services are ready&#10;        self.state_publisher = None&#10;&#10;    def update_state(self, state):&#10;        &quot;&quot;&quot;Update the application state&quot;&quot;&quot;&#10;        print(f&quot;ApplicationStateManager: Updating state to {state}&quot;)&#10;        self.current_state = state&#10;        self.publish_state()&#10;&#10;    def publish_state(self):&#10;        &quot;&quot;&quot;Publish the current state (no arguments needed - used by publisher thread)&quot;&quot;&quot;&#10;        self.message_publisher.publish_state(self.current_state)&#10;&#10;    def __map_process_to_application_state(self, process_state):&#10;        &quot;&quot;&quot;Map GlueProcessState to ApplicationState&quot;&quot;&quot;&#10;        if process_state == ProcessState.PAUSED:&#10;            return ApplicationState.PAUSED&#10;        elif process_state == ProcessState.COMPLETED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == ProcessState.ERROR:&#10;            return ApplicationState.ERROR&#10;        elif process_state == ProcessState.STOPPED:&#10;            return ApplicationState.IDLE&#10;        else:&#10;            return ApplicationState.STARTED&#10;&#10;    def on_process_state_update(self, state):&#10;        &quot;&quot;&quot;Handle glue process state updates&quot;&quot;&quot;&#10;        print(f&quot;Glue process state update received: {state}&quot;)&#10;&#10;        # check if state is GluePrecessState and map to ApplicationState&#10;        if not isinstance(state, ProcessState):&#10;            raise ValueError(f&quot;Invalid state type: {type(state)}. Expected GlueProcessState.&quot;)&#10;        self.update_state(self.__map_process_to_application_state(state))&#10;&#10;    def start_state_publisher_thread(self):&#10;        if self.state_publisher is None:&#10;            self.state_publisher = SystemStatePublisherThread(publish_state_func=self.publish_state, interval=0.1)&#10;            self.state_publisher.start()&#10;&#10;    def stop_state_publisher_thread(self):&#10;        if self.state_publisher:&#10;            self.state_publisher.stop()&#10;            self.state_publisher.join()" />
              <option name="updatedContent" value="from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.application.interfaces.ISubscriptionModule import ISubscriptionModule&#10;&#10;&#10;class SubscriptionManger:&#10;    def __init__(self, owner, broker, subscriptions):&#10;        self.owner = owner&#10;        self.broker = broker&#10;        # Convert list of tuples to dictionary for easier lookup&#10;        if isinstance(subscriptions, list):&#10;            self.subscriptions = {}&#10;            self._initial_subscriptions = subscriptions&#10;        else:&#10;            self.subscriptions = subscriptions&#10;            self._initial_subscriptions = []&#10;        self.modules = []&#10;&#10;    def subscribe_all(self):&#10;        &quot;&quot;&quot;Subscribe all loaded modules.&quot;&quot;&quot;&#10;        # First subscribe to initial subscriptions from constructor&#10;        for subscription in self._initial_subscriptions:&#10;            topic = subscription[0]&#10;            callback = subscription[1]&#10;            print(f&quot;Subscribing to topic: {topic} with callback: {callback}&quot;)&#10;            self._add_subscription(topic, callback)&#10;&#10;    def load_modules(self, modules: list[ISubscriptionModule]):&#10;        for module in modules:&#10;            module.register(self)&#10;            self.modules.append(module)&#10;&#10;    def _add_subscription(self, topic: str, callback):&#10;        self.broker.subscribe(topic, callback)&#10;        self.subscriptions[topic] = callback&#10;&#10;    def _remove_subscription(self, topic):&#10;        if topic in self.subscriptions:&#10;            self.broker.unsubscribe(topic, self.subscriptions[topic])&#10;            del self.subscriptions[topic]&#10;&#10;&#10;from enum import auto, Enum&#10;&#10;from communication_layer.api.v1.topics import VisionTopics, RobotTopics&#10;&#10;&#10;class ApplicationState(Enum):&#10;    &quot;&quot;&quot;Base application states that all robot applications should support&quot;&quot;&quot;&#10;    INITIALIZING = &quot;initializing&quot;&#10;    IDLE = &quot;idle&quot;&#10;    PAUSED = &quot;paused&quot;&#10;    STOPPED = &quot;stopped&quot;&#10;    STARTED = &quot;started&quot;&#10;    ERROR = &quot;error&quot;&#10;    CALIBRATING = &quot;calibrating&quot;&#10;&#10;&#10;class ProcessState(Enum):&#10;    INITIALIZING = auto()&#10;    IDLE = auto()&#10;    STARTING = auto()&#10;    STOPPED = auto()&#10;    PAUSED = auto()&#10;    COMPLETED = auto()&#10;    ERROR = auto()&#10;&#10;&#10;class ApplicationMessagePublisher:&#10;    &quot;&quot;&quot;Extended message publisher for glue dispensing specific messages&quot;&quot;&quot;&#10;&#10;    def __init__(self, broker):&#10;        self.broker=broker&#10;        self.brightness_region_topic = VisionTopics.BRIGHTNESS_REGION&#10;        self.robot_trajectory_image_topic = RobotTopics.TRAJECTORY_UPDATE_IMAGE&#10;        self.trajectory_start_topic = RobotTopics.TRAJECTORY_START&#10;&#10;&#10;    def publish_state(self, state):&#10;        self.broker.publish_state(state)&#10;&#10;    def publish_brightness_region(self, region):&#10;        self.broker.publish(self.brightness_region_topic, {&quot;region&quot;: region})&#10;&#10;    def publish_trajectory_image(self, image):&#10;        self.broker.publish(self.robot_trajectory_image_topic, {&quot;image&quot;: image})&#10;&#10;    def publish_trajectory_start(self):&#10;        self.broker.publish(self.trajectory_start_topic, &quot;&quot;)&#10;&#10;class ApplicationStateManager:&#10;    &quot;&quot;&quot;Extended state manager for glue dispensing specific state handling&quot;&quot;&quot;&#10;&#10;    def __init__(self, message_publisher: ApplicationMessagePublisher):&#10;        self.message_publisher = message_publisher&#10;        self.current_state = ApplicationState.INITIALIZING&#10;        self._services_ready = False  # Flag to indicate when both services are ready&#10;        self.state_publisher = None&#10;&#10;    def update_state(self, state):&#10;        &quot;&quot;&quot;Update the application state&quot;&quot;&quot;&#10;        print(f&quot;ApplicationStateManager: Updating state to {state}&quot;)&#10;        self.current_state = state&#10;        self.publish_state()&#10;&#10;    def publish_state(self):&#10;        &quot;&quot;&quot;Publish the current state (no arguments needed - used by publisher thread)&quot;&quot;&quot;&#10;        self.message_publisher.publish_state(self.current_state)&#10;&#10;    def __map_process_to_application_state(self, process_state):&#10;        &quot;&quot;&quot;Map GlueProcessState to ApplicationState&quot;&quot;&quot;&#10;        if process_state == ProcessState.PAUSED:&#10;            return ApplicationState.PAUSED&#10;        elif process_state == ProcessState.COMPLETED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == ProcessState.ERROR:&#10;            return ApplicationState.ERROR&#10;        elif process_state == ProcessState.STOPPED:&#10;            return ApplicationState.IDLE&#10;        else:&#10;            return ApplicationState.STARTED&#10;&#10;    def on_process_state_update(self, state):&#10;        &quot;&quot;&quot;Handle glue process state updates&quot;&quot;&quot;&#10;        print(f&quot;Glue process state update received: {state}&quot;)&#10;&#10;        # check if state is GluePrecessState and map to ApplicationState&#10;        if not isinstance(state, ProcessState):&#10;            raise ValueError(f&quot;Invalid state type: {type(state)}. Expected GlueProcessState.&quot;)&#10;        self.update_state(self.__map_process_to_application_state(state))&#10;&#10;    def start_state_publisher_thread(self):&#10;        if self.state_publisher is None:&#10;            self.state_publisher = SystemStatePublisherThread(publish_state_func=self.publish_state, interval=0.1)&#10;            self.state_publisher.start()&#10;&#10;    def stop_state_publisher_thread(self):&#10;        if self.state_publisher:&#10;            self.state_publisher.stop()&#10;            self.state_publisher.join()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/base_robot_application.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/base_robot_application.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Base Robot Application&#10;&#10;This module provides the abstract base class for all robot applications.&#10;All specific robot applications (glue dispensing, paint application, etc.)&#10;should inherit from this base class and implement the required abstract methods.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from abc import ABC, abstractmethod&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;from typing import Dict, Any, List&#10;&#10;from communication_layer.api.v1.topics import SystemTopics, RobotTopics&#10;from core.services.robot_service.impl.base_robot_service import BaseRobotService, RobotService&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from modules.shared.MessageBroker import MessageBroker&#10;from core.services.vision.VisionService import _VisionService&#10;from backend.system.settings.SettingsService import SettingsService&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.operations_handlers.camera_calibration_handler import calibrate_camera&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application_state_management import ApplicationState&#10;&#10;&#10;class ApplicationType(Enum):&#10;    &quot;&quot;&quot;Enum defining available robot application types&quot;&quot;&quot;&#10;    GLUE_DISPENSING = &quot;glue_dispensing&quot;&#10;    PAINT_APPLICATION = &quot;paint_application&quot;&#10;&#10;&#10;&#10;&#10;@dataclass&#10;class ApplicationMetadata:&#10;    &quot;&quot;&quot;Metadata for robot applications&quot;&quot;&quot;&#10;    name: str&#10;    version: str&#10;    dependencies: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.dependencies is None:&#10;            self.dependencies = []&#10;&#10;&#10;class BaseRobotApplication(ABC):&#10;    &quot;&quot;&quot;&#10;    Abstract base class for all robot applications.&#10;    &#10;    This class provides the common infrastructure and interface that all&#10;    robot applications should implement. Specific applications like glue&#10;    dispensing, paint application, etc. should inherit from this class.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 robot_service: RobotService,&#10;                 settings_registry:ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        &quot;&quot;&quot;&#10;        Initialize the base robot application.&#10;        &#10;        Args:&#10;            vision_service: Vision system service&#10;            settings_manager: Settings management service&#10;            robot_service: Robot control service&#10;        &quot;&quot;&quot;&#10;&#10;        # Core services&#10;        self.visionService = vision_service&#10;        self.settingsManager = settings_manager&#10;        self.robotService = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.system_state_topic = SystemTopics.SYSTEM_STATE&#10;        self.system_state = SystemState.UNKNOWN&#10;&#10;        # Message broker and communication&#10;        self.broker = MessageBroker()&#10;        self.state_manager = ApplicationStateManager(self.message_publisher)&#10;        # subscribe to system state updates&#10;&#10;&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger, self)&#10;        self.pump = VacuumPump()&#10;        self.laser = Laser()&#10;        self.robotService.tool_manager = self.tool_manager&#10;&#10;&#10;        # Initialize application&#10;        self._initialize_application()&#10;&#10;    def get_subscriptions(self):&#10;        subscriptions = []&#10;        # SUBSCRIBE TO PROCESS STATE UPDATES&#10;        process_state_subscription = [SystemTopics.PROCESS_STATE,self.state_manager.on_process_state_update]&#10;        # SUBSCRIBE TO MODE CHANGE UPDATES&#10;        mode_change_subscription = [SystemTopics.SYSTEM_MODE_CHANGE,self.on_mode_change]&#10;        # SUBSCRIBE TO SYSTEM STATE UPDATES&#10;        system_state_subscription = [self.system_state_topic,self.on_system_state_update]&#10;        subscriptions.append(system_state_subscription)&#10;        subscriptions.append(process_state_subscription)&#10;        subscriptions.append(mode_change_subscription)&#10;        return subscriptions&#10;&#10;    def on_system_state_update(self, state):&#10;        self.system_state = state&#10;&#10;    &#10;    @staticmethod&#10;    @abstractmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        &quot;&quot;&quot;Return application metadata&quot;&quot;&quot;&#10;        return ApplicationMetadata(name=&quot;BaseRobotApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;&#10; &#10;&#10;&#10;    def _initialize_application(self):&#10;        &quot;&quot;&quot;Initialize the application infrastructure&quot;&quot;&quot;&#10;        # Start camera feed in separate thread&#10;        self.cameraThread = threading.Thread(target=self.visionService.run, daemon=True)&#10;        self.cameraThread.start()&#10;    &#10;    # Abstract methods that must be implemented by specific applications&#10;&#10;    @abstractmethod&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result and any relevant data&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def stop(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    @abstractmethod&#10;    def on_mode_change(self,mode):&#10;        &quot;&quot;&quot;&#10;        Handle mode change requests.&#10;&#10;        Args:&#10;            mode: New mode to switch to&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_robot(self)&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_camera(self)&#10;    &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;Shutdown the application and cleanup resources&quot;&quot;&quot;&#10;        # self.state_manager.update_state(ApplicationState.STOPPED)&#10;        # self.state_manager.stop_state_publisher_thread()&#10;        # self.subscription_manager.unsubscribe_all()&#10;        pass&#10;    # Optional methods for application-specific features&#10;    &#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;&#10;        Get list of operations supported by this application.&#10;        Can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return [&quot;start&quot;, &quot;stop&quot;, &quot;pause&quot;, &quot;resume&quot;, &quot;calibrate_robot&quot;, &quot;calibrate_camera&quot;]&#10;    &#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Validate the current application configuration.&#10;        Can be overridden by specific applications.&#10;        &#10;        Returns:&#10;            Dict with validation result and any issues found&#10;        &quot;&quot;&quot;&#10;        return {&#10;            &quot;valid&quot;: True,&#10;            &quot;issues&quot;: []&#10;        }" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Base Robot Application&#10;&#10;This module provides the abstract base class for all robot applications.&#10;All specific robot applications (glue dispensing, paint application, etc.)&#10;should inherit from this base class and implement the required abstract methods.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from abc import ABC, abstractmethod&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;from typing import Dict, Any, List&#10;&#10;from communication_layer.api.v1.topics import SystemTopics, RobotTopics&#10;from core.services.robot_service.impl.base_robot_service import BaseRobotService, RobotService&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from modules.shared.MessageBroker import MessageBroker&#10;from core.services.vision.VisionService import _VisionService&#10;from backend.system.settings.SettingsService import SettingsService&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.operations_handlers.camera_calibration_handler import calibrate_camera&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application_state_management import ApplicationState&#10;&#10;&#10;class ApplicationType(Enum):&#10;    &quot;&quot;&quot;Enum defining available robot application types&quot;&quot;&quot;&#10;    GLUE_DISPENSING = &quot;glue_dispensing&quot;&#10;    PAINT_APPLICATION = &quot;paint_application&quot;&#10;&#10;&#10;&#10;@dataclass&#10;class ApplicationMetadata:&#10;    &quot;&quot;&quot;Metadata for robot applications&quot;&quot;&quot;&#10;    name: str&#10;    version: str&#10;    dependencies: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.dependencies is None:&#10;            self.dependencies = []&#10;&#10;&#10;class BaseRobotApplication(ABC):&#10;    &quot;&quot;&quot;&#10;    Abstract base class for all robot applications.&#10;    &#10;    This class provides the common infrastructure and interface that all&#10;    robot applications should implement. Specific applications like glue&#10;    dispensing, paint application, etc. should inherit from this class.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 robot_service: RobotService,&#10;                 settings_registry:ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        &quot;&quot;&quot;&#10;        Initialize the base robot application.&#10;        &#10;        Args:&#10;            vision_service: Vision system service&#10;            settings_manager: Settings management service&#10;            robot_service: Robot control service&#10;        &quot;&quot;&quot;&#10;&#10;        # Core services&#10;        self.visionService = vision_service&#10;        self.settingsManager = settings_manager&#10;        self.robotService = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.system_state_topic = SystemTopics.SYSTEM_STATE&#10;        self.system_state = SystemState.UNKNOWN&#10;&#10;        # Message broker and communication&#10;        self.broker = MessageBroker()&#10;        self.state_manager = ApplicationStateManager(self.message_publisher)&#10;        # subscribe to system state updates&#10;&#10;&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger, self)&#10;        self.pump = VacuumPump()&#10;        self.laser = Laser()&#10;        self.robotService.tool_manager = self.tool_manager&#10;&#10;&#10;        # Initialize application&#10;        self._initialize_application()&#10;&#10;    def get_subscriptions(self):&#10;        subscriptions = []&#10;        # SUBSCRIBE TO PROCESS STATE UPDATES&#10;        process_state_subscription = [SystemTopics.PROCESS_STATE,self.state_manager.on_process_state_update]&#10;        # SUBSCRIBE TO MODE CHANGE UPDATES&#10;        mode_change_subscription = [SystemTopics.SYSTEM_MODE_CHANGE,self.on_mode_change]&#10;        # SUBSCRIBE TO SYSTEM STATE UPDATES&#10;        system_state_subscription = [self.system_state_topic,self.on_system_state_update]&#10;        subscriptions.append(system_state_subscription)&#10;        subscriptions.append(process_state_subscription)&#10;        subscriptions.append(mode_change_subscription)&#10;        return subscriptions&#10;&#10;    def on_system_state_update(self, state):&#10;        self.system_state = state&#10;&#10;    &#10;    @staticmethod&#10;    @abstractmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        &quot;&quot;&quot;Return application metadata&quot;&quot;&quot;&#10;        return ApplicationMetadata(name=&quot;BaseRobotApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;&#10; &#10;&#10;&#10;    def _initialize_application(self):&#10;        &quot;&quot;&quot;Initialize the application infrastructure&quot;&quot;&quot;&#10;        # Start camera feed in separate thread&#10;        self.cameraThread = threading.Thread(target=self.visionService.run, daemon=True)&#10;        self.cameraThread.start()&#10;    &#10;    # Abstract methods that must be implemented by specific applications&#10;&#10;    @abstractmethod&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result and any relevant data&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def stop(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    @abstractmethod&#10;    def on_mode_change(self,mode):&#10;        &quot;&quot;&quot;&#10;        Handle mode change requests.&#10;&#10;        Args:&#10;            mode: New mode to switch to&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_robot(self)&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_camera(self)&#10;    &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;Shutdown the application and cleanup resources&quot;&quot;&quot;&#10;        # self.state_manager.update_state(ApplicationState.STOPPED)&#10;        # self.state_manager.stop_state_publisher_thread()&#10;        # self.subscription_manager.unsubscribe_all()&#10;        pass&#10;    # Optional methods for application-specific features&#10;    &#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;&#10;        Get list of operations supported by this application.&#10;        Can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return [&quot;start&quot;, &quot;stop&quot;, &quot;pause&quot;, &quot;resume&quot;, &quot;calibrate_robot&quot;, &quot;calibrate_camera&quot;]&#10;    &#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Validate the current application configuration.&#10;        Can be overridden by specific applications.&#10;        &#10;        Returns:&#10;            Dict with validation result and any issues found&#10;        &quot;&quot;&quot;&#10;        return {&#10;            &quot;valid&quot;: True,&#10;            &quot;issues&quot;: []&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/services/robot_service/impl/base_robot_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/services/robot_service/impl/base_robot_service.py" />
              <option name="originalContent" value="import threading&#10;import time&#10;from typing import Optional&#10;&#10;from backend.system.utils.custom_logging import log_info_message, log_debug_message, setup_logger, LoggerContext&#10;from backend.system.utils import robot_utils&#10;from communication_layer.api.v1.topics import RobotTopics, VisionTopics&#10;from core.model.robot.IRobot import IRobot&#10;from core.services.robot_service.impl.robot_monitor.state_manager import BaseRobotServiceStateManager&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from core.state_management import ServiceState, ServiceStateMessage&#10;from frontend.core.services.domain.RobotService import RobotAxis&#10;&#10;from core.model.robot.enums.axis import Direction&#10;from core.services.robot_service.enums.RobotState import RobotState&#10;from modules.shared.MessageBroker import MessageBroker&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from modules.shared.tools.ToolChanger import ToolChanger&#10;from modules.shared.tools.ToolManager import ToolManager&#10;&#10;ENABLE_ROBOT_SERVICE_LOGGING = True&#10;&#10;&#10;class CancellationToken:&#10;    &quot;&quot;&quot;&#10;    Cancellation token for controlling robot operations.&#10;&#10;    This provides a clean way to cancel robot operations without&#10;    directly coupling to state machines.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self._cancelled = threading.Event()&#10;        self._reason = None&#10;        self._timestamp = None&#10;&#10;    def cancel(self, reason: str = &quot;cancelled&quot;):&#10;        &quot;&quot;&quot;Cancel the operation.&quot;&quot;&quot;&#10;        self._cancelled.set()&#10;        self._reason = reason&#10;        self._timestamp = time.time()&#10;&#10;    def is_cancelled(self) -&gt; bool:&#10;        &quot;&quot;&quot;Check if the operation has been cancelled.&quot;&quot;&quot;&#10;        return self._cancelled.is_set()&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;Reset the cancellation token.&quot;&quot;&quot;&#10;        self._cancelled.clear()&#10;        self._reason = None&#10;        self._timestamp = None&#10;&#10;    def get_cancellation_reason(self) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Get the reason for cancellation.&quot;&quot;&quot;&#10;        return self._reason&#10;&#10;    def get_cancellation_timestamp(self) -&gt; Optional[float]:&#10;        &quot;&quot;&quot;Get the timestamp when cancellation occurred.&quot;&quot;&quot;&#10;        return self._timestamp&#10;&#10;class RobotServiceMessagePublisher:&#10;    def __init__(self,broker,service_id):&#10;        self.broker = broker&#10;        self.service_id = service_id&#10;        self.state_topic = RobotTopics.SERVICE_STATE&#10;        self.trajectory_stop_topic = RobotTopics.TRAJECTORY_STOP&#10;        self.trajectory_break_topic = RobotTopics.TRAJECTORY_BREAK&#10;        self.threshold_region_topic = VisionTopics.THRESHOLD_REGION&#10;&#10;    def publish_state(self,state):&#10;        self.broker.publish(self.state_topic, state)&#10;&#10;    def publish_trajectory_stop_topic(self):&#10;        self.broker.publish(self.trajectory_stop_topic, &quot;&quot;)&#10;&#10;    def publish_trajectory_break_topic(self):&#10;        self.broker.publish(self.trajectory_break_topic, {})&#10;&#10;    def publish_threshold_region_topic(self,region):&#10;        self.broker.publish(self.threshold_region_topic, {&quot;region&quot;:region})&#10;&#10;class BaseRobotService(IRobotService):&#10;    def __init__(self, robot:IRobot, settings_service, robot_state_manager):&#10;        self.robot = robot&#10;        self.service_id = &quot;robot_service&quot;&#10;        self.settings_service = settings_service&#10;        self.robot_config = self.settings_service.robot_config&#10;        self._operation_lock = threading.Lock()&#10;        self.enable_logging = ENABLE_ROBOT_SERVICE_LOGGING&#10;        self.robot_state_manager = robot_state_manager&#10;        self.broker = MessageBroker()&#10;        self.message_publisher = RobotServiceMessagePublisher(self.broker,self.service_id)&#10;        self.state_manager = BaseRobotServiceStateManager(ServiceState.INITIALIZING, self.message_publisher, self,self.service_id)&#10;        self.robot_state_manager.start_monitoring()&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger,self)&#10;        if self.enable_logging:&#10;            self.logger = setup_logger(&quot;RobotService&quot;)&#10;        else:&#10;            self.logger = None&#10;        self.logger_context = LoggerContext(enabled=self.enable_logging,&#10;                                            logger=self.logger)&#10;&#10;    @property&#10;    def current_tool(self):&#10;        return self.tool_manager.current_gripper&#10;&#10;    def moveToStartPosition(self, z_offset=0):&#10;        &quot;&quot;&quot;Move robot to start position&quot;&quot;&quot;&#10;        try:&#10;            position = self.robot_config.getHomePositionParsed()&#10;            print(f&quot;Position before z offset: {position}&quot;)&#10;            # apply the z offset to account for the calibration pattern thickness&#10;            position[2] += z_offset&#10;            print(f&quot;Position with z offset: {position}&quot;)&#10;            config = self.robot_config.getHomePosConfig()&#10;&#10;            ret = self.robot.move_cartesian(&#10;                position=position,&#10;                tool=self.robot_config.robot_tool,&#10;                user=self.robot_config.robot_user,&#10;                vel=config.velocity,&#10;                acc=config.acceleration&#10;            )&#10;&#10;            print(f&quot;Moving to start position, result: {ret}&quot;)&#10;            self.message_publisher.publish_threshold_region_topic(&quot;pickup&quot;)&#10;            return ret&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error moving to start position: {e}&quot;)&#10;            return -1&#10;&#10;    def pickupGripper(self, gripper_id, callback=None):&#10;        &quot;&quot;&quot;Delegate pickup to ToolManager&quot;&quot;&quot;&#10;        success, message = self.tool_manager.pickup_gripper(gripper_id)&#10;        if callback:&#10;            callback(success, message)&#10;        return success, message&#10;&#10;    def dropOffGripper(self, gripper_id, callback=None):&#10;        &quot;&quot;&quot;Delegate drop off to ToolManager&quot;&quot;&quot;&#10;        success, message = self.tool_manager.drop_off_gripper(gripper_id)&#10;        if callback:&#10;            callback(success, message)&#10;        return success, message&#10;&#10;    def moveToLoginPosition(self):&#10;        ret = None&#10;        currentPos = self.get_current_position()&#10;        x, y, z, rx, ry, rz = currentPos&#10;&#10;        if y &gt; 350:&#10;            ret = self.move_to_calibration_position()&#10;            if ret != 0:&#10;                return ret&#10;&#10;            ret = self.moveToStartPosition()&#10;            if ret != 0:&#10;                return ret&#10;        else:&#10;            ret = self.moveToStartPosition()&#10;            if ret != 0:&#10;                return ret&#10;&#10;        position = self.robot_config.getLoginPositionParsed()  # This already handles None case&#10;        loginPositionConfig = self.robot_config.getLoginPosConfig()&#10;        velocity = loginPositionConfig.velocity&#10;        acceleration = loginPositionConfig.acceleration&#10;        ret = self.robot.move_cartesian(position=position,&#10;                                  tool=self.robot_config.robot_tool,&#10;                                  user=self.robot_config.robot_user,&#10;                                  vel=velocity,&#10;                                  acc=acceleration)&#10;        return ret&#10;&#10;    def move_to_calibration_position(self,z_offset=0):&#10;        &quot;&quot;&quot;Move robot to calibration position&quot;&quot;&quot;&#10;        try:&#10;            position = self.robot_config.getCalibrationPositionParsed()&#10;            # apply the z offset to account for the calibration pattern thickness&#10;            position[2] += z_offset&#10;            config = self.robot_config.getCalibrationPosConfig()&#10;&#10;            ret = self.robot.move_cartesian(&#10;                position=position,&#10;                tool=self.robot_config.robot_tool,&#10;                user=self.robot_config.robot_user,&#10;                vel=config.velocity,&#10;                acc=config.acceleration&#10;            )&#10;&#10;            self.message_publisher.publish_threshold_region_topic(&quot;spray&quot;)&#10;            return ret&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error moving to calibration position: {e}&quot;)&#10;            return -1&#10;&#10;    def reload_config(self):&#10;        self.robot_config = self.settings_service.reload_robot_config()&#10;&#10;    def stop_motion(self)-&gt; bool:&#10;        &quot;&quot;&quot;Stop robot motion safely&quot;&quot;&quot;&#10;        result = False&#10;        with self._operation_lock:&#10;            max_attempts = 5&#10;            for attempt in range(max_attempts):&#10;                try:&#10;                    result = self.robot.stop_motion()&#10;                    log_info_message(self.logger_context, message=f&quot;Robot motion stopped, result: {result}&quot;)&#10;                    result = True&#10;                    break&#10;                except Exception as e:&#10;                    if &quot;Request-sent&quot; in str(e) and attempt &lt; max_attempts - 1:&#10;                        time.sleep(0.1)  # Wait and retry&#10;                        continue&#10;                    else:&#10;                        raise&#10;        return result&#10;&#10;    def start_jog(self, axis, direction, step):&#10;        step = float(step)&#10;        # Set sign based on direction&#10;        if direction == Direction.MINUS:&#10;            temp_step = abs(step)&#10;            print(f&quot;Direction minus, step set to {temp_step}&quot;)&#10;        else:&#10;            temp_step = -abs(step)&#10;            print(f&quot;Direction plus, step set to {temp_step}&quot;)&#10;&#10;        if axis == RobotAxis.Z:&#10;            currentPos = self.get_current_position()&#10;            proposedZ = currentPos[2] + temp_step&#10;            print(f&quot;RobotService: startJog: current Z: {currentPos[2]}, proposed Z: {proposedZ}&quot;)&#10;            if proposedZ &lt; self.robot_config.safety_limits.z_min:&#10;                print(&#10;                    f&quot;Jog Z to {proposedZ}mm exceeds minimum limit of {self.robot_config.safety_limits.z_min}mm. Jog cancelled.&quot;)&#10;                return -1&#10;            if proposedZ &gt; self.robot_config.safety_limits.z_max:&#10;                print(&#10;                    f&quot;Jog Z to {proposedZ}mm exceeds maximum limit of {self.robot_config.safety_limits.z_max}mm. Jog cancelled.&quot;)&#10;                return -1&#10;&#10;        result = self.robot.start_jog(axis=axis,&#10;                                      direction=direction,&#10;                                      step=step,&#10;                                      vel=self.robot_config.getJogConfig().velocity,&#10;                                      acc=self.robot_config.getJogConfig().acceleration)&#10;        print(f&quot;RobotService: startJog: result: {result}&quot;)&#10;        return result&#10;&#10;    def is_within_safety_limits(self, position):&#10;        &quot;&quot;&quot;Check if position is within safety limits&quot;&quot;&quot;&#10;        safety_config = self.robot_config.safety_limits&#10;        pos_x, pos_y, pos_z = position[0], position[1], position[2]&#10;&#10;        if pos_z &gt; safety_config.z_max:&#10;            print(f&quot;Position Z {pos_z} exceeds maximum limit of {safety_config.z_max}&quot;)&#10;            return False&#10;&#10;        if pos_z &lt; safety_config.z_min:&#10;            print(f&quot;Position Z {pos_z} is below minimum limit of {safety_config.z_min}&quot;)&#10;            return False&#10;&#10;        return True&#10;&#10;    def move_to_position(self, position, tool, workpiece, velocity, acceleration, waitToReachPosition=False):&#10;        &quot;&quot;&quot;&#10;        Moves the robot to a specified position with optional waiting.&#10;&#10;        Args:&#10;            position (list): Target Cartesian position&#10;            tool (int): Tool frame ID&#10;            workpiece (int): Workpiece frame ID&#10;            velocity (float): Speed&#10;            acceleration (float): Acceleration&#10;            waitToReachPosition (bool): If True, waits for robot to reach position&#10;        &quot;&quot;&quot;&#10;&#10;        # check if position is within safety limits&#10;        result = self.is_within_safety_limits(position)&#10;        if not result:&#10;            return False&#10;&#10;        ret = self.robot.move_cartesian(position, tool, workpiece, vel=velocity, acc=acceleration)&#10;&#10;        if waitToReachPosition:  # TODO comment out when using test robot&#10;            self._waitForRobotToReachPosition(position, 2, delay=0.1)&#10;&#10;        # self.robot.move_liner(position, tool, workpieces, vel=velocity, acc=acceleration,blendR=20)&#10;        return ret&#10;&#10;    def _waitForRobotToReachPosition(self, endPoint, threshold, delay, timeout=1, cancellation_token=None):&#10;        &quot;&quot;&quot;Wait for robot to reach target position with state awareness&quot;&quot;&quot;&#10;        start_time = time.time()&#10;        log_info_message(self.logger_context,&#10;                         message=f&quot;_waitForRobotToReachPosition CALLED WITH  endPoint={endPoint},threshold={threshold},delay = {delay},timeout = {timeout}&quot;)&#10;&#10;        while True:&#10;            print(f&quot;RobotService: Waiting for robot to reach position {endPoint} with threshold {threshold}mm&quot;)&#10;            # Check cancellation token (replaces state machine dependency)&#10;            if cancellation_token is not None and cancellation_token.is_cancelled():&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Operation cancelled via cancellation token: {cancellation_token.get_cancellation_reason()}&quot;)&#10;                return False&#10;&#10;            # Check timeout&#10;            if time.time() - start_time &gt; timeout:&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Timeout reached while waiting for robot position {endPoint}&quot;)&#10;                return False&#10;&#10;            # Check position&#10;            current_position = self.get_current_position()&#10;            if current_position is None:&#10;                time.sleep(0.1)&#10;                continue&#10;&#10;            distance = robot_utils.calculate_distance_between_points(current_position, endPoint)&#10;&#10;            if distance &lt; threshold:&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Robot reached target position {endPoint} within threshold {threshold}mm&quot;)&#10;                return True&#10;&#10;            time.sleep(0.01)&#10;&#10;    def get_current_velocity(self):&#10;        &quot;&quot;&quot;Get current robot velocity&quot;&quot;&quot;&#10;        return self.robot_state_manager.velocity&#10;&#10;    def get_current_acceleration(self):&#10;        &quot;&quot;&quot;Get current robot acceleration&quot;&quot;&quot;&#10;        return self.robot_state_manager.acceleration&#10;&#10;    def get_current_position(self):&#10;        &quot;&quot;&quot;Get current robot position&quot;&quot;&quot;&#10;        return self.robot_state_manager.position&#10;        # return self.robot.getCurrentPosition()&#10;&#10;    def enable_robot(self):&#10;        &quot;&quot;&quot;Enable robot motion&quot;&quot;&quot;&#10;        self.robot.enable()&#10;        print(&quot;Robot enabled&quot;)&#10;&#10;    def disable_robot(self):&#10;        &quot;&quot;&quot;Disable robot motion&quot;&quot;&quot;&#10;        self.robot.disable()&#10;        print(&quot;Robot disabled&quot;)&#10;&#10;    def get_state(self):&#10;        &quot;&quot;&quot;Get current robot state&quot;&quot;&quot;&#10;        return self.robot_state_manager.state&#10;&#10;    def get_state_topic(self) -&gt; str:&#10;        return self.message_publisher.state_topic" />
              <option name="updatedContent" value="import threading&#10;import time&#10;from typing import Optional&#10;&#10;from backend.system.utils.custom_logging import log_info_message, log_debug_message, setup_logger, LoggerContext&#10;from backend.system.utils import robot_utils&#10;from communication_layer.api.v1.topics import RobotTopics, VisionTopics&#10;from core.model.robot.IRobot import IRobot&#10;from core.services.robot_service.impl.robot_monitor.state_manager import BaseRobotServiceStateManager&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from core.state_management import ServiceState, ServiceStateMessage&#10;from frontend.core.services.domain.RobotService import RobotAxis&#10;&#10;from core.model.robot.enums.axis import Direction&#10;from core.services.robot_service.enums.RobotState import RobotState&#10;from modules.shared.MessageBroker import MessageBroker&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from modules.shared.tools.ToolChanger import ToolChanger&#10;from modules.shared.tools.ToolManager import ToolManager&#10;&#10;ENABLE_ROBOT_SERVICE_LOGGING = True&#10;&#10;&#10;class CancellationToken:&#10;    &quot;&quot;&quot;&#10;    Cancellation token for controlling robot operations.&#10;&#10;    This provides a clean way to cancel robot operations without&#10;    directly coupling to state machines.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self._cancelled = threading.Event()&#10;        self._reason = None&#10;        self._timestamp = None&#10;&#10;    def cancel(self, reason: str = &quot;cancelled&quot;):&#10;        &quot;&quot;&quot;Cancel the operation.&quot;&quot;&quot;&#10;        self._cancelled.set()&#10;        self._reason = reason&#10;        self._timestamp = time.time()&#10;&#10;    def is_cancelled(self) -&gt; bool:&#10;        &quot;&quot;&quot;Check if the operation has been cancelled.&quot;&quot;&quot;&#10;        return self._cancelled.is_set()&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;Reset the cancellation token.&quot;&quot;&quot;&#10;        self._cancelled.clear()&#10;        self._reason = None&#10;        self._timestamp = None&#10;&#10;    def get_cancellation_reason(self) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Get the reason for cancellation.&quot;&quot;&quot;&#10;        return self._reason&#10;&#10;    def get_cancellation_timestamp(self) -&gt; Optional[float]:&#10;        &quot;&quot;&quot;Get the timestamp when cancellation occurred.&quot;&quot;&quot;&#10;        return self._timestamp&#10;&#10;class RobotServiceMessagePublisher:&#10;    def __init__(self,broker,service_id):&#10;        self.broker = broker&#10;        self.service_id = service_id&#10;        self.state_topic = RobotTopics.SERVICE_STATE&#10;        self.trajectory_stop_topic = RobotTopics.TRAJECTORY_STOP&#10;        self.trajectory_break_topic = RobotTopics.TRAJECTORY_BREAK&#10;        self.threshold_region_topic = VisionTopics.THRESHOLD_REGION&#10;&#10;    def publish_state(self,state):&#10;        self.broker.publish(self.state_topic, state)&#10;&#10;    def publish_trajectory_stop_topic(self):&#10;        self.broker.publish(self.trajectory_stop_topic, &quot;&quot;)&#10;&#10;    def publish_trajectory_break_topic(self):&#10;        self.broker.publish(self.trajectory_break_topic, {})&#10;&#10;    def publish_threshold_region_topic(self,region):&#10;        self.broker.publish(self.threshold_region_topic, {&quot;region&quot;:region})&#10;&#10;class BaseRobotService(IRobotService):&#10;    def __init__(self, robot:IRobot, settings_service, robot_state_manager):&#10;        self.robot = robot&#10;        self.service_id = &quot;robot_service&quot;&#10;        self.settings_service = settings_service&#10;        self.robot_config = self.settings_service.robot_config&#10;        self._operation_lock = threading.Lock()&#10;        self.enable_logging = ENABLE_ROBOT_SERVICE_LOGGING&#10;        self.robot_state_manager = robot_state_manager&#10;        self.broker = MessageBroker()&#10;        self.message_publisher = RobotServiceMessagePublisher(self.broker,self.service_id)&#10;        self.state_manager = BaseRobotServiceStateManager(ServiceState.INITIALIZING, self.message_publisher, self,self.service_id)&#10;        self.robot_state_manager.start_monitoring()&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger,self)&#10;        if self.enable_logging:&#10;            self.logger = setup_logger(&quot;RobotService&quot;)&#10;        else:&#10;            self.logger = None&#10;        self.logger_context = LoggerContext(enabled=self.enable_logging,&#10;                                            logger=self.logger)&#10;&#10;    @property&#10;    def current_tool(self):&#10;        return self.tool_manager.current_gripper&#10;&#10;    def moveToStartPosition(self, z_offset=0):&#10;        &quot;&quot;&quot;Move robot to start position&quot;&quot;&quot;&#10;        try:&#10;            position = self.robot_config.getHomePositionParsed()&#10;            print(f&quot;Position before z offset: {position}&quot;)&#10;            # apply the z offset to account for the calibration pattern thickness&#10;            position[2] += z_offset&#10;            print(f&quot;Position with z offset: {position}&quot;)&#10;            config = self.robot_config.getHomePosConfig()&#10;&#10;            ret = self.robot.move_cartesian(&#10;                position=position,&#10;                tool=self.robot_config.robot_tool,&#10;                user=self.robot_config.robot_user,&#10;                vel=config.velocity,&#10;                acc=config.acceleration&#10;            )&#10;&#10;            print(f&quot;Moving to start position, result: {ret}&quot;)&#10;            self.message_publisher.publish_threshold_region_topic(&quot;pickup&quot;)&#10;            return ret&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error moving to start position: {e}&quot;)&#10;            return -1&#10;&#10;    def pickupGripper(self, gripper_id, callback=None):&#10;        &quot;&quot;&quot;Delegate pickup to ToolManager&quot;&quot;&quot;&#10;        success, message = self.tool_manager.pickup_gripper(gripper_id)&#10;        if callback:&#10;            callback(success, message)&#10;        return success, message&#10;&#10;    def dropOffGripper(self, gripper_id, callback=None):&#10;        &quot;&quot;&quot;Delegate drop off to ToolManager&quot;&quot;&quot;&#10;        success, message = self.tool_manager.drop_off_gripper(gripper_id)&#10;        if callback:&#10;            callback(success, message)&#10;        return success, message&#10;&#10;    def moveToLoginPosition(self):&#10;        ret = None&#10;        currentPos = self.get_current_position()&#10;        x, y, z, rx, ry, rz = currentPos&#10;&#10;        if y &gt; 350:&#10;            ret = self.move_to_calibration_position()&#10;            if ret != 0:&#10;                return ret&#10;&#10;            ret = self.moveToStartPosition()&#10;            if ret != 0:&#10;                return ret&#10;        else:&#10;            ret = self.moveToStartPosition()&#10;            if ret != 0:&#10;                return ret&#10;&#10;        position = self.robot_config.getLoginPositionParsed()  # This already handles None case&#10;        loginPositionConfig = self.robot_config.getLoginPosConfig()&#10;        velocity = loginPositionConfig.velocity&#10;        acceleration = loginPositionConfig.acceleration&#10;        ret = self.robot.move_cartesian(position=position,&#10;                                  tool=self.robot_config.robot_tool,&#10;                                  user=self.robot_config.robot_user,&#10;                                  vel=velocity,&#10;                                  acc=acceleration)&#10;        return ret&#10;&#10;    def move_to_calibration_position(self,z_offset=0):&#10;        &quot;&quot;&quot;Move robot to calibration position&quot;&quot;&quot;&#10;        try:&#10;            position = self.robot_config.getCalibrationPositionParsed()&#10;            # apply the z offset to account for the calibration pattern thickness&#10;            position[2] += z_offset&#10;            config = self.robot_config.getCalibrationPosConfig()&#10;&#10;            ret = self.robot.move_cartesian(&#10;                position=position,&#10;                tool=self.robot_config.robot_tool,&#10;                user=self.robot_config.robot_user,&#10;                vel=config.velocity,&#10;                acc=config.acceleration&#10;            )&#10;&#10;            self.message_publisher.publish_threshold_region_topic(&quot;spray&quot;)&#10;            return ret&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error moving to calibration position: {e}&quot;)&#10;            return -1&#10;&#10;    def reload_config(self):&#10;        self.robot_config = self.settings_service.reload_robot_config()&#10;&#10;    def stop_motion(self)-&gt; bool:&#10;        &quot;&quot;&quot;Stop robot motion safely&quot;&quot;&quot;&#10;        result = False&#10;        with self._operation_lock:&#10;            max_attempts = 5&#10;            for attempt in range(max_attempts):&#10;                try:&#10;                    result = self.robot.stop_motion()&#10;                    log_info_message(self.logger_context, message=f&quot;Robot motion stopped, result: {result}&quot;)&#10;                    result = True&#10;                    break&#10;                except Exception as e:&#10;                    if &quot;Request-sent&quot; in str(e) and attempt &lt; max_attempts - 1:&#10;                        time.sleep(0.1)  # Wait and retry&#10;                        continue&#10;                    else:&#10;                        raise&#10;        return result&#10;&#10;    def start_jog(self, axis, direction, step):&#10;        step = float(step)&#10;        # Set sign based on direction&#10;        if direction == Direction.MINUS:&#10;            temp_step = abs(step)&#10;            print(f&quot;Direction minus, step set to {temp_step}&quot;)&#10;        else:&#10;            temp_step = -abs(step)&#10;            print(f&quot;Direction plus, step set to {temp_step}&quot;)&#10;&#10;        if axis == RobotAxis.Z:&#10;            currentPos = self.get_current_position()&#10;            proposedZ = currentPos[2] + temp_step&#10;            print(f&quot;RobotService: startJog: current Z: {currentPos[2]}, proposed Z: {proposedZ}&quot;)&#10;            if proposedZ &lt; self.robot_config.safety_limits.z_min:&#10;                print(&#10;                    f&quot;Jog Z to {proposedZ}mm exceeds minimum limit of {self.robot_config.safety_limits.z_min}mm. Jog cancelled.&quot;)&#10;                return -1&#10;            if proposedZ &gt; self.robot_config.safety_limits.z_max:&#10;                print(&#10;                    f&quot;Jog Z to {proposedZ}mm exceeds maximum limit of {self.robot_config.safety_limits.z_max}mm. Jog cancelled.&quot;)&#10;                return -1&#10;&#10;        result = self.robot.start_jog(axis=axis,&#10;                                      direction=direction,&#10;                                      step=step,&#10;                                      vel=self.robot_config.getJogConfig().velocity,&#10;                                      acc=self.robot_config.getJogConfig().acceleration)&#10;        print(f&quot;RobotService: startJog: result: {result}&quot;)&#10;        return result&#10;&#10;    def is_within_safety_limits(self, position):&#10;        &quot;&quot;&quot;Check if position is within safety limits&quot;&quot;&quot;&#10;        safety_config = self.robot_config.safety_limits&#10;        pos_x, pos_y, pos_z = position[0], position[1], position[2]&#10;&#10;        if pos_z &gt; safety_config.z_max:&#10;            print(f&quot;Position Z {pos_z} exceeds maximum limit of {safety_config.z_max}&quot;)&#10;            return False&#10;&#10;        if pos_z &lt; safety_config.z_min:&#10;            print(f&quot;Position Z {pos_z} is below minimum limit of {safety_config.z_min}&quot;)&#10;            return False&#10;&#10;        return True&#10;&#10;    def move_to_position(self, position, tool, workpiece, velocity, acceleration, waitToReachPosition=False):&#10;        &quot;&quot;&quot;&#10;        Moves the robot to a specified position with optional waiting.&#10;&#10;        Args:&#10;            position (list): Target Cartesian position&#10;            tool (int): Tool frame ID&#10;            workpiece (int): Workpiece frame ID&#10;            velocity (float): Speed&#10;            acceleration (float): Acceleration&#10;            waitToReachPosition (bool): If True, waits for robot to reach position&#10;        &quot;&quot;&quot;&#10;&#10;        # check if position is within safety limits&#10;        result = self.is_within_safety_limits(position)&#10;        if not result:&#10;            return False&#10;&#10;        ret = self.robot.move_cartesian(position, tool, workpiece, vel=velocity, acc=acceleration)&#10;&#10;        if waitToReachPosition:  # TODO comment out when using test robot&#10;            self._waitForRobotToReachPosition(position, 2, delay=0.1)&#10;&#10;        # self.robot.move_liner(position, tool, workpieces, vel=velocity, acc=acceleration,blendR=20)&#10;        return ret&#10;&#10;    def _waitForRobotToReachPosition(self, endPoint, threshold, delay, timeout=1, cancellation_token=None):&#10;        &quot;&quot;&quot;Wait for robot to reach target position with state awareness&quot;&quot;&quot;&#10;        start_time = time.time()&#10;        log_info_message(self.logger_context,&#10;                         message=f&quot;_waitForRobotToReachPosition CALLED WITH  endPoint={endPoint},threshold={threshold},delay = {delay},timeout = {timeout}&quot;)&#10;&#10;        while True:&#10;            print(f&quot;RobotService: Waiting for robot to reach position {endPoint} with threshold {threshold}mm&quot;)&#10;            # Check cancellation token (replaces state machine dependency)&#10;            if cancellation_token is not None and cancellation_token.is_cancelled():&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Operation cancelled via cancellation token: {cancellation_token.get_cancellation_reason()}&quot;)&#10;                return False&#10;&#10;            # Check timeout&#10;            if time.time() - start_time &gt; timeout:&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Timeout reached while waiting for robot position {endPoint}&quot;)&#10;                return False&#10;&#10;            # Check position&#10;            current_position = self.get_current_position()&#10;            if current_position is None:&#10;                time.sleep(0.1)&#10;                continue&#10;&#10;            distance = robot_utils.calculate_distance_between_points(current_position, endPoint)&#10;&#10;            if distance &lt; threshold:&#10;                log_debug_message(self.logger_context,&#10;                                  message=f&quot;Robot reached target position {endPoint} within threshold {threshold}mm&quot;)&#10;                return True&#10;&#10;            time.sleep(0.01)&#10;&#10;    def get_current_velocity(self):&#10;        &quot;&quot;&quot;Get current robot velocity&quot;&quot;&quot;&#10;        return self.robot_state_manager.velocity&#10;&#10;    def get_current_acceleration(self):&#10;        &quot;&quot;&quot;Get current robot acceleration&quot;&quot;&quot;&#10;        return self.robot_state_manager.acceleration&#10;&#10;    def get_current_position(self):&#10;        &quot;&quot;&quot;Get current robot position&quot;&quot;&quot;&#10;        return self.robot_state_manager.position&#10;        # return self.robot.getCurrentPosition()&#10;&#10;    def enable_robot(self):&#10;        &quot;&quot;&quot;Enable robot motion&quot;&quot;&quot;&#10;        self.robot.enable()&#10;        print(&quot;Robot enabled&quot;)&#10;&#10;    def disable_robot(self):&#10;        &quot;&quot;&quot;Disable robot motion&quot;&quot;&quot;&#10;        self.robot.disable()&#10;        print(&quot;Robot disabled&quot;)&#10;&#10;    def get_state(self):&#10;        &quot;&quot;&quot;Get current robot state&quot;&quot;&quot;&#10;        return self.robot_state_manager.state&#10;&#10;    def get_state_topic(self) -&gt; str:&#10;        return self.message_publisher.state_topic" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>