<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application_state_management.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application_state_management.py" />
              <option name="originalContent" value="from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.application.interfaces.ISubscriptionModule import ISubscriptionModule&#10;from core.operation_state_management import OperationState&#10;&#10;&#10;class SubscriptionManger:&#10;    def __init__(self, owner, broker, subscriptions):&#10;        self.owner = owner&#10;        self.broker = broker&#10;        # Convert list of tuples to dictionary for easier lookup&#10;        if isinstance(subscriptions, list):&#10;            self.subscriptions = {}&#10;            self._initial_subscriptions = subscriptions&#10;        else:&#10;            self.subscriptions = subscriptions&#10;            self._initial_subscriptions = []&#10;        self.modules = []&#10;&#10;    def subscribe_all(self):&#10;        &quot;&quot;&quot;Subscribe all loaded modules.&quot;&quot;&quot;&#10;        # First subscribe to initial subscriptions from constructor&#10;        for subscription in self._initial_subscriptions:&#10;            topic = subscription[0]&#10;            callback = subscription[1]&#10;            print(f&quot;Subscribing to topic: {topic} with callback: {callback}&quot;)&#10;            self._add_subscription(topic, callback)&#10;&#10;    def load_modules(self, modules: list[ISubscriptionModule]):&#10;        for module in modules:&#10;            module.register(self)&#10;            self.modules.append(module)&#10;&#10;    def _add_subscription(self, topic: str, callback):&#10;        self.broker.subscribe(topic, callback)&#10;        self.subscriptions[topic] = callback&#10;&#10;    def _remove_subscription(self, topic):&#10;        if topic in self.subscriptions:&#10;            self.broker.unsubscribe(topic, self.subscriptions[topic])&#10;            del self.subscriptions[topic]&#10;&#10;&#10;from enum import auto, Enum&#10;&#10;from communication_layer.api.v1.topics import VisionTopics, RobotTopics, SystemTopics&#10;&#10;&#10;class ApplicationState(Enum):&#10;    &quot;&quot;&quot;Base application states that all robot applications should support&quot;&quot;&quot;&#10;    INITIALIZING = &quot;initializing&quot;&#10;    IDLE = &quot;idle&quot;&#10;    PAUSED = &quot;paused&quot;&#10;    STOPPED = &quot;stopped&quot;&#10;    STARTED = &quot;started&quot;&#10;    ERROR = &quot;error&quot;&#10;    CALIBRATING = &quot;calibrating&quot;&#10;&#10;class ApplicationMessagePublisher:&#10;    &quot;&quot;&quot;Extended message publisher for glue dispensing specific messages&quot;&quot;&quot;&#10;&#10;    def __init__(self, broker):&#10;        self.broker=broker&#10;        self.brightness_region_topic = VisionTopics.BRIGHTNESS_REGION&#10;        self.robot_trajectory_image_topic = RobotTopics.TRAJECTORY_UPDATE_IMAGE&#10;        self.trajectory_start_topic = RobotTopics.TRAJECTORY_START&#10;&#10;&#10;    def publish_state(self, state):&#10;        self.broker.publish(topic=SystemTopics.APPLICATION_STATE, message=state)&#10;&#10;    def publish_brightness_region(self, region):&#10;        self.broker.publish(self.brightness_region_topic, {&quot;region&quot;: region})&#10;&#10;    def publish_trajectory_image(self, image):&#10;        self.broker.publish(self.robot_trajectory_image_topic, {&quot;image&quot;: image})&#10;&#10;    def publish_trajectory_start(self):&#10;        self.broker.publish(self.trajectory_start_topic, &quot;&quot;)&#10;&#10;class ApplicationStateManager:&#10;    &quot;&quot;&quot;Extended state manager for glue dispensing specific state handling&quot;&quot;&quot;&#10;&#10;    def __init__(self, message_publisher: ApplicationMessagePublisher):&#10;        self.message_publisher = message_publisher&#10;        self.current_state = ApplicationState.INITIALIZING&#10;        self._services_ready = False  # Flag to indicate when both services are ready&#10;        self.state_publisher = None&#10;        self.system_state = None&#10;        self.process_state = None&#10;&#10;    def update_state(self, state):&#10;        &quot;&quot;&quot;Update the application state&quot;&quot;&quot;&#10;        print(f&quot;ApplicationStateManager: Updating state to {state}&quot;)&#10;        self.current_state = state&#10;        self.publish_state()&#10;&#10;    def publish_state(self):&#10;        &quot;&quot;&quot;Publish the current state (no arguments needed - used by publisher thread)&quot;&quot;&quot;&#10;        # print(f&quot;ApplicationStateManager: Publishing state {self.current_state}&quot;)&#10;        self.message_publisher.publish_state(self.current_state)&#10;&#10;    def __map_operation_to_application_state(self, process_state):&#10;        &quot;&quot;&quot;Map GlueProcessState to ApplicationState&quot;&quot;&quot;&#10;        if process_state == OperationState.PAUSED:&#10;            return ApplicationState.PAUSED&#10;        elif process_state == OperationState.COMPLETED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == OperationState.ERROR:&#10;            return ApplicationState.ERROR&#10;        elif process_state == OperationState.STOPPED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == OperationState.IDLE:&#10;            return ApplicationState.IDLE&#10;        else:&#10;            return ApplicationState.STARTED&#10;&#10;    def on_operation_state_update(self, state):&#10;        &quot;&quot;&quot;Handle glue process state updates&quot;&quot;&quot;&#10;        print(f&quot;[APPLICATION STATE MANAGER] Operation state update received: {state}&quot;)&#10;        print(f&quot;[APPLICATION STATE MANAGER] State type: {type(state)}&quot;)&#10;        print(f&quot;[APPLICATION STATE MANAGER] Is OperationState: {isinstance(state, OperationState)}&quot;)&#10;        # check if state is GluePrecessState and map to ApplicationState&#10;        if not isinstance(state, OperationState):&#10;            raise ValueError(f&quot;Invalid state type: {type(state)}. Expected GlueProcessState.&quot;)&#10;        self.update_state(self.__map_operation_to_application_state(state))&#10;&#10;    def start_state_publisher_thread(self):&#10;        if self.state_publisher is None:&#10;            self.state_publisher = SystemStatePublisherThread(publish_state_func=self.publish_state, interval=0.1)&#10;            self.state_publisher.start()&#10;&#10;    def stop_state_publisher_thread(self):&#10;        if self.state_publisher:&#10;            self.state_publisher.stop()&#10;            self.state_publisher.join()" />
              <option name="updatedContent" value="from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.application.interfaces.ISubscriptionModule import ISubscriptionModule&#10;from core.operation_state_management import OperationState&#10;&#10;&#10;class SubscriptionManger:&#10;    def __init__(self, owner, broker, subscriptions):&#10;        self.owner = owner&#10;        self.broker = broker&#10;        # Convert list of tuples to dictionary for easier lookup&#10;        if isinstance(subscriptions, list):&#10;            self.subscriptions = {}&#10;            self._initial_subscriptions = subscriptions&#10;        else:&#10;            self.subscriptions = subscriptions&#10;            self._initial_subscriptions = []&#10;        self.modules = []&#10;&#10;    def subscribe_all(self):&#10;        &quot;&quot;&quot;Subscribe all loaded modules.&quot;&quot;&quot;&#10;        # First subscribe to initial subscriptions from constructor&#10;        for subscription in self._initial_subscriptions:&#10;            topic = subscription[0]&#10;            callback = subscription[1]&#10;            print(f&quot;Subscribing to topic: {topic} with callback: {callback}&quot;)&#10;            self._add_subscription(topic, callback)&#10;&#10;    def load_modules(self, modules: list[ISubscriptionModule]):&#10;        for module in modules:&#10;            module.register(self)&#10;            self.modules.append(module)&#10;&#10;    def _add_subscription(self, topic: str, callback):&#10;        self.broker.subscribe(topic, callback)&#10;        self.subscriptions[topic] = callback&#10;&#10;    def _remove_subscription(self, topic):&#10;        if topic in self.subscriptions:&#10;            self.broker.unsubscribe(topic, self.subscriptions[topic])&#10;            del self.subscriptions[topic]&#10;&#10;&#10;from enum import auto, Enum&#10;&#10;from communication_layer.api.v1.topics import VisionTopics, RobotTopics, SystemTopics&#10;&#10;&#10;class ApplicationState(Enum):&#10;    &quot;&quot;&quot;Base application states that all robot applications should support&quot;&quot;&quot;&#10;    INITIALIZING = &quot;initializing&quot;&#10;    IDLE = &quot;idle&quot;&#10;    PAUSED = &quot;paused&quot;&#10;    STOPPED = &quot;stopped&quot;&#10;    STARTED = &quot;started&quot;&#10;    ERROR = &quot;error&quot;&#10;    CALIBRATING = &quot;calibrating&quot;&#10;&#10;class ApplicationMessagePublisher:&#10;    &quot;&quot;&quot;Extended message publisher for glue dispensing specific messages&quot;&quot;&quot;&#10;&#10;    def __init__(self, broker):&#10;        self.broker=broker&#10;        self.brightness_region_topic = VisionTopics.BRIGHTNESS_REGION&#10;        self.robot_trajectory_image_topic = RobotTopics.TRAJECTORY_UPDATE_IMAGE&#10;        self.trajectory_start_topic = RobotTopics.TRAJECTORY_START&#10;&#10;&#10;    def publish_state(self, state):&#10;        self.broker.publish(topic=SystemTopics.APPLICATION_STATE, message=state)&#10;&#10;    def publish_brightness_region(self, region):&#10;        self.broker.publish(self.brightness_region_topic, {&quot;region&quot;: region})&#10;&#10;    def publish_trajectory_image(self, image):&#10;        self.broker.publish(self.robot_trajectory_image_topic, {&quot;image&quot;: image})&#10;&#10;    def publish_trajectory_start(self):&#10;        self.broker.publish(self.trajectory_start_topic, &quot;&quot;)&#10;&#10;class ApplicationStateManager:&#10;    &quot;&quot;&quot;Extended state manager for glue dispensing specific state handling&quot;&quot;&quot;&#10;&#10;    def __init__(self, message_publisher: ApplicationMessagePublisher):&#10;        self.message_publisher = message_publisher&#10;        self.current_state = ApplicationState.INITIALIZING&#10;        self._services_ready = False  # Flag to indicate when both services are ready&#10;        self.state_publisher = None&#10;        self.system_state = None&#10;        self.process_state = None&#10;&#10;    def update_state(self, state):&#10;        &quot;&quot;&quot;Update the application state&quot;&quot;&quot;&#10;        print(f&quot;ApplicationStateManager: Updating state to {state}&quot;)&#10;        self.current_state = state&#10;        self.publish_state()&#10;&#10;    def publish_state(self):&#10;        &quot;&quot;&quot;Publish the current state (no arguments needed - used by publisher thread)&quot;&quot;&quot;&#10;        # print(f&quot;ApplicationStateManager: Publishing state {self.current_state}&quot;)&#10;        self.message_publisher.publish_state(self.current_state)&#10;&#10;    def __map_operation_to_application_state(self, process_state):&#10;        &quot;&quot;&quot;Map GlueProcessState to ApplicationState&quot;&quot;&quot;&#10;        if process_state == OperationState.PAUSED:&#10;            return ApplicationState.PAUSED&#10;        elif process_state == OperationState.COMPLETED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == OperationState.ERROR:&#10;            return ApplicationState.ERROR&#10;        elif process_state == OperationState.STOPPED:&#10;            return ApplicationState.IDLE&#10;        elif process_state == OperationState.IDLE:&#10;            return ApplicationState.IDLE&#10;        else:&#10;            return ApplicationState.STARTED&#10;&#10;    def on_operation_state_update(self, state):&#10;        &quot;&quot;&quot;Handle glue process state updates&quot;&quot;&quot;&#10;        print(f&quot;[APPLICATION STATE MANAGER] Operation state update received: {state}&quot;)&#10;        print(f&quot;[APPLICATION STATE MANAGER] State type: {type(state)}&quot;)&#10;        print(f&quot;[APPLICATION STATE MANAGER] Is OperationState: {isinstance(state, OperationState)}&quot;)&#10;        # check if state is GluePrecessState and map to ApplicationState&#10;        if not isinstance(state, OperationState):&#10;            raise ValueError(f&quot;Invalid state type: {type(state)}. Expected GlueProcessState.&quot;)&#10;        self.update_state(self.__map_operation_to_application_state(state))&#10;&#10;    def start_state_publisher_thread(self):&#10;        if self.state_publisher is None:&#10;            self.state_publisher = SystemStatePublisherThread(publish_state_func=self.publish_state, interval=0.1)&#10;            self.state_publisher.start()&#10;&#10;    def stop_state_publisher_thread(self):&#10;        if self.state_publisher:&#10;            self.state_publisher.stop()&#10;            self.state_publisher.join()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/base_robot_application.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/base_robot_application.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Base Robot Application&#10;&#10;This module provides the abstract base class for all robot applications.&#10;All specific robot applications (glue dispensing, paint application, etc.)&#10;should inherit from this base class and implement the required abstract methods.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from abc import ABC, abstractmethod&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;from typing import Dict, Any, List&#10;&#10;from communication_layer.api.v1.topics import SystemTopics, RobotTopics&#10;from core.services.robot_service.impl.base_robot_service import  RobotService&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from core.system_state_management import SystemState&#10;from modules.shared.MessageBroker import MessageBroker&#10;from core.services.vision.VisionService import _VisionService&#10;from backend.system.settings.SettingsService import SettingsService&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.operations_handlers.camera_calibration_handler import calibrate_camera&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application_state_management import ApplicationState, ApplicationStateManager, ApplicationMessagePublisher&#10;from modules.shared.tools.Laser import Laser&#10;from modules.shared.tools.ToolChanger import ToolChanger&#10;from modules.shared.tools.ToolManager import ToolManager&#10;from modules.shared.tools.VacuumPump import VacuumPump&#10;&#10;&#10;class ApplicationType(Enum):&#10;    &quot;&quot;&quot;Enum defining available robot application types&quot;&quot;&quot;&#10;    GLUE_DISPENSING = &quot;glue_dispensing&quot;&#10;    PAINT_APPLICATION = &quot;paint_application&quot;&#10;&#10;&#10;&#10;&#10;@dataclass&#10;class ApplicationMetadata:&#10;    &quot;&quot;&quot;Metadata for robot applications&quot;&quot;&quot;&#10;    name: str&#10;    version: str&#10;    dependencies: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.dependencies is None:&#10;            self.dependencies = []&#10;&#10;&#10;class BaseRobotApplication(ABC):&#10;    &quot;&quot;&quot;&#10;    Abstract base class for all robot applications.&#10;    &#10;    This class provides the common infrastructure and interface that all&#10;    robot applications should implement. Specific applications like glue&#10;    dispensing, paint application, etc. should inherit from this class.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 robot_service: RobotService,&#10;                 settings_registry:ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        &quot;&quot;&quot;&#10;        Initialize the base robot application.&#10;        &#10;        Args:&#10;            vision_service: Vision system service&#10;            settings_manager: Settings management service&#10;            robot_service: Robot control service&#10;        &quot;&quot;&quot;&#10;&#10;        # Core services&#10;        self.visionService = vision_service&#10;        self.settingsManager = settings_manager&#10;        self.robotService = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.system_state_topic = SystemTopics.SYSTEM_STATE&#10;        self.system_state = SystemState.UNKNOWN&#10;&#10;        # Message broker and communication&#10;        self.broker = MessageBroker()&#10;        self.message_publisher = ApplicationMessagePublisher(self.broker)&#10;        self.state_manager = ApplicationStateManager(self.message_publisher)&#10;        self.state_manager.start_state_publisher_thread()&#10;        # subscribe to system state updates&#10;&#10;&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger, self)&#10;        self.pump = VacuumPump()&#10;        self.laser = Laser()&#10;        self.tool_manager.add_tool(&quot;laser&quot;, self.laser)&#10;        self.tool_manager.add_tool(&quot;vacuum_pump&quot;, self.pump)&#10;        self.robotService.tool_manager = self.tool_manager&#10;&#10;&#10;        # Initialize application&#10;        self._initialize_application()&#10;&#10;    def get_subscriptions(self):&#10;        subscriptions = []&#10;        # SUBSCRIBE TO PROCESS STATE UPDATES&#10;        process_state_subscription = [SystemTopics.OPERATION_STATE, self.state_manager.on_operation_state_update]&#10;        # SUBSCRIBE TO MODE CHANGE UPDATES&#10;        mode_change_subscription = [SystemTopics.SYSTEM_MODE_CHANGE,self.on_mode_change]&#10;        # SUBSCRIBE TO SYSTEM STATE UPDATES&#10;        system_state_subscription = [self.system_state_topic,self.on_system_state_update]&#10;&#10;        subscriptions.append(system_state_subscription)&#10;        subscriptions.append(process_state_subscription)&#10;        subscriptions.append(mode_change_subscription)&#10;        return subscriptions&#10;&#10;    def on_system_state_update(self, state):&#10;        self.system_state = state&#10;&#10;    @staticmethod&#10;    @abstractmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        &quot;&quot;&quot;Return application metadata&quot;&quot;&quot;&#10;        return ApplicationMetadata(name=&quot;BaseRobotApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;&#10; &#10;&#10;&#10;    def _initialize_application(self):&#10;        &quot;&quot;&quot;Initialize the application infrastructure&quot;&quot;&quot;&#10;        # Start camera feed in separate thread&#10;        self.cameraThread = threading.Thread(target=self.visionService.run, daemon=True)&#10;        self.cameraThread.start()&#10;    &#10;    # Abstract methods that must be implemented by specific applications&#10;&#10;    @abstractmethod&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result and any relevant data&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def stop(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    @abstractmethod&#10;    def on_mode_change(self,mode):&#10;        &quot;&quot;&quot;&#10;        Handle mode change requests.&#10;&#10;        Args:&#10;            mode: New mode to switch to&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_robot(self)&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_camera(self)&#10;    &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;Shutdown the application and cleanup resources&quot;&quot;&quot;&#10;        # self.state_manager.update_state(ApplicationState.STOPPED)&#10;        # self.state_manager.stop_state_publisher_thread()&#10;        # self.subscription_manager.unsubscribe_all()&#10;        pass&#10;    # Optional methods for application-specific features&#10;    &#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;&#10;        Get list of operations supported by this application.&#10;        Can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return [&quot;start&quot;, &quot;stop&quot;, &quot;pause&quot;, &quot;resume&quot;, &quot;calibrate_robot&quot;, &quot;calibrate_camera&quot;]&#10;    &#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Validate the current application configuration.&#10;        Can be overridden by specific applications.&#10;        &#10;        Returns:&#10;            Dict with validation result and any issues found&#10;        &quot;&quot;&quot;&#10;        return {&#10;            &quot;valid&quot;: True,&#10;            &quot;issues&quot;: []&#10;        }" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Base Robot Application&#10;&#10;This module provides the abstract base class for all robot applications.&#10;All specific robot applications (glue dispensing, paint application, etc.)&#10;should inherit from this base class and implement the required abstract methods.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from abc import ABC, abstractmethod&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;from typing import Dict, Any, List&#10;&#10;from communication_layer.api.v1.topics import SystemTopics, RobotTopics&#10;from core.services.robot_service.impl.base_robot_service import  RobotService&#10;from core.services.robot_service.interfaces.IRobotService import IRobotService&#10;from core.system_state_management import SystemState&#10;from modules.shared.MessageBroker import MessageBroker&#10;from core.services.vision.VisionService import _VisionService&#10;from backend.system.settings.SettingsService import SettingsService&#10;from backend.system.SystemStatePublisherThread import SystemStatePublisherThread&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.operations_handlers.camera_calibration_handler import calibrate_camera&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application_state_management import ApplicationState, ApplicationStateManager, ApplicationMessagePublisher&#10;from modules.shared.tools.Laser import Laser&#10;from modules.shared.tools.ToolChanger import ToolChanger&#10;from modules.shared.tools.ToolManager import ToolManager&#10;from modules.shared.tools.VacuumPump import VacuumPump&#10;&#10;&#10;class ApplicationType(Enum):&#10;    &quot;&quot;&quot;Enum defining available robot application types&quot;&quot;&quot;&#10;    GLUE_DISPENSING = &quot;glue_dispensing&quot;&#10;    PAINT_APPLICATION = &quot;paint_application&quot;&#10;&#10;&#10;&#10;&#10;@dataclass&#10;class ApplicationMetadata:&#10;    &quot;&quot;&quot;Metadata for robot applications&quot;&quot;&quot;&#10;    name: str&#10;    version: str&#10;    dependencies: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.dependencies is None:&#10;            self.dependencies = []&#10;&#10;&#10;class BaseRobotApplication(ABC):&#10;    &quot;&quot;&quot;&#10;    Abstract base class for all robot applications.&#10;    &#10;    This class provides the common infrastructure and interface that all&#10;    robot applications should implement. Specific applications like glue&#10;    dispensing, paint application, etc. should inherit from this class.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 robot_service: RobotService,&#10;                 settings_registry:ApplicationSettingsRegistry,&#10;                 **kwargs&#10;                 ):&#10;        &quot;&quot;&quot;&#10;        Initialize the base robot application.&#10;        &#10;        Args:&#10;            vision_service: Vision system service&#10;            settings_manager: Settings management service&#10;            robot_service: Robot control service&#10;        &quot;&quot;&quot;&#10;&#10;        # Core services&#10;        self.visionService = vision_service&#10;        self.settingsManager = settings_manager&#10;        self.robotService = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.system_state_topic = SystemTopics.SYSTEM_STATE&#10;        self.system_state = SystemState.UNKNOWN&#10;&#10;        # Message broker and communication&#10;        self.broker = MessageBroker()&#10;        self.message_publisher = ApplicationMessagePublisher(self.broker)&#10;        self.state_manager = ApplicationStateManager(self.message_publisher)&#10;        self.state_manager.start_state_publisher_thread()&#10;        # subscribe to system state updates&#10;&#10;&#10;        self.toolChanger = ToolChanger()&#10;        self.tool_manager = ToolManager(self.toolChanger, self)&#10;        self.pump = VacuumPump()&#10;        self.laser = Laser()&#10;        self.tool_manager.add_tool(&quot;laser&quot;, self.laser)&#10;        self.tool_manager.add_tool(&quot;vacuum_pump&quot;, self.pump)&#10;        self.robotService.tool_manager = self.tool_manager&#10;&#10;&#10;        # Initialize application&#10;        self._initialize_application()&#10;&#10;    def get_subscriptions(self):&#10;        subscriptions = []&#10;        # SUBSCRIBE TO PROCESS STATE UPDATES&#10;        process_state_subscription = [SystemTopics.OPERATION_STATE, self.state_manager.on_operation_state_update]&#10;        # SUBSCRIBE TO MODE CHANGE UPDATES&#10;        mode_change_subscription = [SystemTopics.SYSTEM_MODE_CHANGE,self.on_mode_change]&#10;        # SUBSCRIBE TO SYSTEM STATE UPDATES&#10;        system_state_subscription = [self.system_state_topic,self.on_system_state_update]&#10;&#10;        subscriptions.append(system_state_subscription)&#10;        subscriptions.append(process_state_subscription)&#10;        subscriptions.append(mode_change_subscription)&#10;        return subscriptions&#10;&#10;    def on_system_state_update(self, state):&#10;        self.system_state = state&#10;&#10;    @staticmethod&#10;    @abstractmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        &quot;&quot;&quot;Return application metadata&quot;&quot;&quot;&#10;        return ApplicationMetadata(name=&quot;BaseRobotApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;&#10; &#10;&#10;&#10;    def _initialize_application(self):&#10;        &quot;&quot;&quot;Initialize the application infrastructure&quot;&quot;&quot;&#10;        # Start camera feed in separate thread&#10;        self.cameraThread = threading.Thread(target=self.visionService.run, daemon=True)&#10;        self.cameraThread.start()&#10;    &#10;    # Abstract methods that must be implemented by specific applications&#10;&#10;    @abstractmethod&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result and any relevant data&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def stop(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def resume(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;&#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    @abstractmethod&#10;    def on_mode_change(self,mode):&#10;        &quot;&quot;&quot;&#10;        Handle mode change requests.&#10;&#10;        Args:&#10;            mode: New mode to switch to&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_robot(self)&#10;    &#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return calibrate_camera(self)&#10;    &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;Shutdown the application and cleanup resources&quot;&quot;&quot;&#10;        # self.state_manager.update_state(ApplicationState.STOPPED)&#10;        # self.state_manager.stop_state_publisher_thread()&#10;        # self.subscription_manager.unsubscribe_all()&#10;        pass&#10;    # Optional methods for application-specific features&#10;    &#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;&#10;        Get list of operations supported by this application.&#10;        Can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return [&quot;start&quot;, &quot;stop&quot;, &quot;pause&quot;, &quot;resume&quot;, &quot;calibrate_robot&quot;, &quot;calibrate_camera&quot;]&#10;    &#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Validate the current application configuration.&#10;        Can be overridden by specific applications.&#10;        &#10;        Returns:&#10;            Dict with validation result and any issues found&#10;        &quot;&quot;&quot;&#10;        return {&#10;            &quot;valid&quot;: True,&#10;            &quot;issues&quot;: []&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>